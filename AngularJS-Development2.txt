*****Angular NX :
****For create a workspace : "npx create-nx-workspace@latest".
****Local olarak nx workspacedeki bir applicationu run etmek için : "npx nx serve applicationName".
****Local olarak nx workspacedeki bir applicationu build etmek için : "npx nx build applicationName".
-------------------------------------------------------------------------------------------------------------------------------------------
*****Github repoya eklemek için:
1-Projenine terminaline gel ve "git init" yaz.
2-"git add ." yaz.
3-"git commit -m 'first commit'" yaz.
4-"git remote -v" yazarak uzaktan bağlantıyı kontrol et.Eğer response vermiyorsa veya farklı repoya response veriyorsa, bağlantıyı kurmak için "git remote add origin https://github.com/UCB52/homepage_replication_1.git" yaz.
6-"git push -u origin main" yaz.Eğer mastera ekleyeceksek de "git push origin master" yaz.
-------------------------------------------------------------------------------------------------------------------------------------------
*****JSON-serverlı projeyi herokuda kurmak:
1-Eğer yüklü değilse, bilgisayarına herokuyu "npm install -g heroku" yazarak yükle.
2-Heroku websitesine gir ve login ol.
3-Projeninin terminaline "heroku login" yaz ve login ol.Eğer auth başarılı olursa, terminalde belirtecektir.
4-Projenin ana dizinine gel ve "Procfile" dosyası oluşturarak içine şunu yaz: "web: node server.js".
5-Ana dizinde "server.js" dosyası oluştur ve içerisine şöyle yaz:
"const jsonServer = require('json-server');
const server = jsonServer.create();
const router = jsonServer.router('./data.json');  !WARNING
const middlewares = jsonServer.defaults({
  static: './build'
});
const PORT = process.env.PORT || 8000;  !WARNING
server.use(middlewares);
server.use(jsonServer.rewriter({
  '/api/*': '/$1',
}))
server.use(router);
server.listen(PORT, () => {
  console.log('Server is running');
});"
6-Bu nodejs dosyasındaki json-server configinde json dosyasının adına ve api portuna dikkat et.
7-Heroku websitesine gir ve "create new app" butonuna tıkla.Appin ismini gir ve regionunu seçerek oluştur.
5-Açılan ekranda "Deployment method" kısmındayız."heroku cli" ile yükleyeceğiz.Proje dizinine gel ve "heroku git:remote -a angular-replika1" yaz.Başarılı olursa response gelecek.
6-"git add ." yaz.
7-"git commit -m 'first commit'" yaz.Eğer olmazsa da "git commit -am 'make it better'" yaz.
8-Eğer master repo ise "git push heroku master" yazarak pushla; eğer main repo ise de "git push heroku main" yazarak pushla.
-------------------------------------------------------------------------------------------------------------------------------------------
*****HEROKU:
1-Herokuda app oluştur.Mesela "herokuApp1" olsun.
1-"heroku login" yaz.
2-"git init" yaz.
3-"heroku git:remote -a herokuApp1" yaz.
4-"git add ." yaz.
5-"git commit -am 'first commit'" yaz.
6-"git push heroku master" yaz.
-------------------------------------------------------------------------------------------------------------------------------------------
****E2E testler eklemek için :
***Bu senaryoda, "angular1" applikasyonu için test queryleri yazıcaz:
1-"apps/angular1-e2e/src/support/app.po.ts." dosyasını aç.Burada pagei sorgulamak[querying] için helperları içeren test metodlarını yazarız.Mesela şöyle yazalım:
"export const getGreeting = () => cy.get('h1');
export const getLiNumber1 = () => cy.get('li.li1');
export const getAddButton = () => cy.get('button#button1');"
2-Ardından "apps/angular1-e2e/src/integration/app.spec.ts." dosyasını aç.Yazdığımız query metodlarını burada "it" metodu içerisinde şöyle çağırırız:
"import { getAddButton, getGreeting, getLiNumber1 } from '../support/app.po';
describe('angular1', () => {
  beforeEach(() => cy.visit('/'));
  it('should display welcome message', () => {
    cy.login('my-email@something.com', 'myPassword');
    getGreeting().contains('Welcome angular1');
    getLiNumber1().should((t) => expect(t.length).equal(2));
    getAddButton().click();
    getLiNumber1().should((t) => expect(t.length).equal(3));
  });
});"
3-Ardından sayfa htmline gel ve testlerde belirttiklerimizi şöyle yaz : 
"<h1>Welcome angular1</h1>
<ol>
  <li *ngFor='let x of object1' class='li1'>{{x.title}}</li>
</ol>
<button (click)='addElementLi()' id='button1'>Add new Li</button>"
4-Böylece yazdığımız testteki queryler sırayla çalışacak ve testten başarıyla geçecek.
-------------------------------------------------------------------------------------------------------------------------------------------
*****MAİN SCHEMA: Modules-Components-Services>>>Guards-Directives-Pipes
*Install Angular: npm install -g @angular/cli
*Angular Version Check: ng --version
*New angular application: ng new applicationName
*Live compile: ng serve -o
*Material UI: ng add @angular/material (yes-yes)
*New child component: ng g c componentName
*Child component for spesifik "module": ng g c componentName --module ../app.module.ts
*New routing module: ng g m routingName --flat --module=app
*Generate custom pipes: ng g p pipes/pipeName
*New directives: ng g directive directiveName
*if-else: <div ngIf="color2=='orange'; else template6"></div>
*if-else: <div ngIf="color2=='orange'; then template5 else template6"></div>
*else-if: <ng-template #template1 [ngIf]>="color3=='purple'"</ng-template>
*switch: [ngSwitch]="color1"
*case: *ngSwitchCase="'red'"
*array loop: *ngFor="let y of x.array"
*Conditional class add: [class.some-css-class]="some-condition"
*@Input
*@Output
*EventEmitter
*new EventEmitter<type>()
*emit
*function($event)
*Binding [(ngModel)]="data"
*Variable type: HTMLInputElement,HTMLMediaElement,HTMLMenuElement,HTMLLinkElementany,[],number[],string[],
[string,string,number],{},{name:string,age:number},Date
*Pipes: |uppercase|lowecase|date|date:'fullDate'|slice:x[include]:y[exclude]|json
|number:'3.3-5'|currency:'GBP'|currency:'TRY':'TL':'4[min].2[min]-2[max]'
*For custom pipes: {{value|pipe1:'args'}}
*For form modules: import { FormsModule } from '@angular/forms';
imports[FormsModule]
*Form stuff: (ngsubmit), #loginForm1="ngForm", ngModel
*For Reactative Forms: import {ReactiveFormsModule} from '@angular/forms';
imports[ReactiveFormsModule]
import {FormGroup,FormControl} from '@angular/forms';
*****Decoration içerisindeki componentin HTMLini 2 şekilde belirtiriz:
1-templateUrl = Default ayardır.HTML belgesini işaret eder.Mesela: './app1.component.html'.
2-template = İçerisine HTML taglariyle yazarız ve böylece bu kodları tanır.Mesela: `<h1>Test{{string1}}</h1>`.
*****Decoration içerisindeki componentin STYLEını 2 şekilde belirtiriz:
1-styleUrls = Default ayardır.Style belgelerini işaret eder.Mesela: './app1.component.css'.
2-styles = İçerisine CSS yazarız ve böylece kodları tanır.Mesela: "[h1{color:'red'}]".
*****Componentlere "decorator" eklemek için:
1-Component içerisine "@Component({})" yaz.
2-Süslü parantez içerisine "selector" ekle.Mesela: "selector:'app-product'".
3-Süslü parantez içerisine "template" veya "templateUrl" ekle.Mesela: "templateUrl:'./product.component.html'".
4-Süslü parantez içerisine "styles" veya "styleUrls" ekle.Mesela: "styleUrls:['./product.component.css']".
5-Süslü parantez içerisine "providers" ekle.Mesela: "providers[AlertifyService]".Bunu sadece lokal servis kullanmak istersek yaparız.
6-Eklenen itemlerin aralarına virgül[,] koymayı unutma.
*****Servicelere "decorator" eklemek için:
1-Service içerisine "@Injectable({})" yaz.
2-Süslü parantez içerisine de "providedIn: 'root'" ekleriz.Buradaki "root" ifadesi, bu servicein "global" olduğunu belirtir.Bunun alternatifi ise, "appModule"e girip, "providers[]" arrayinin içerisine oluşturduğumuz servicein ismini ekleriz.Eğer bir servisi lokal kullanmak istersek, süslü parantez içerisinde silerek; kullanacağımız componentin içerisine gireriz ve oraya ekleriz.
------------------------------------------------------------------------------------------
*****Standalone componentler eklemek için[only Angular14+]:
1-Terminale gel ve mesela şöyle yaz:
"ng g c home --standalone --flat".
2-Böylece artık generate edilen componentler, "app.module" componentinde toplanmayacaklar.Dolayısıyla artık ekstra bir module ihtiyacımız varsa, standalone componentimizin kendisine import edeceğiz.
------------------------------------------------------------------------------------------
*****Jquery eklemek için:
1-"npm install jquery --save" kodunu cmdden yaz.
2-"angular.json" dosyasındaki "scripts" arrayinin içerisine "node_modules/jquery/dist/jquery.min.js" yaz.
3-Component içerisinde kullanırken "declare var $ : any;" deklerasyonunu yapmamız gerekir. 
*****Bootstrap eklemek için:
1-"index.html" içerisine CDN ekle.Eğer olmazsa da 2. adımı izle.
2-"ng add @ng-bootstrap/ng-bootstrap" kodunu cmdden yaz.Böylece hem normal Bootstrap hem de AngularBootstrap yüklenecektir.
3-Ardından "angular.json" içerisinde "styles[]" arrayini bulup içerisine 
"node_modules/bootstrap/dist/css/bootstrap.min.css" ekle.
*****Bootstrap icons eklemek için:
1-"npm i bootstrap-icons" kodunu cmdden yaz.Eğer olmazsa da "index.html" içerisine CDN ekle.
*****Font-awesome eklemek için:
1-"npm install @fortawesome/fontawesome-free" kodunu cmdden yaz."node_modules" içerisine ekledi.
2-"angular.json" içerisinde "styles" arrayini bulup içerisine 
"node_modules/@fortawesome/fontawesome-free/css/all.min.css" ekle.
-------------------------------------------------------------------------------------------------------------
*****alertifyjs eklemek için:
1-"npm i alertifyjs" kodunu cmdden yaz.Böylece "node_modules" içerisine eklenecek.
2-Daha sonra "angular.json" içerisine girip "scripts[]" arrayini bul.Buraya eklediğimiz alertify pathını şöyle gireriz: "node_modules/alertifyjs/build/alertify.min.js".
3-Ardından yine burada "styles[]" arrayini bularak alertifyin css ve bootstrapini şöyle ekleriz:
"node_modules/alertifyjs/build/css/alertify.min.css",
"node_modules/alertifyjs/build/css/themes/bootstrap.min.css".
4-Fakat alertifyı kullanacağınız componentlerin içerisinde "declare let alertify:any" şeklinde deklare etmemiz gerekir.
-------------------------------------------------------------------------------------------------------------
*****Service eklemek için:
1-Önce "app" içerisine bir "services" folder oluştur çünkü serviceleri, bu folderın içerisine ekleyeceğiz.
2-Terminal ile services için oluşturulan folderın pathına gel ve "ng g s serviceName" yaz.
3-Eğer global olmasını istiyorsak, decoratora dokunmayız.Fakat local yapmak istersek, decorator içerisine temizleriz.Ardından eklemek istediğimiz componente gelip, "Providers: []" arrayı oluşturup, içerisine de local servisleri ekleriz.
-------------------------------------------------------------------------------------------------------------
*****HttpClient "service"te "get" kullanmak için:
1-"appModule" içerisine girerek import için "import {HttpClientModule} from '@angular/common/http'" ekle.
2-Ardından da "imports[]" arrayine "HttpClientModule" ekle.Ve "providers[]" arrayını şöyle yap: "providers: [{ provide: 'apiUrl', useValue: 'http://localhost:3000/' }]".Böylece api urlsini, servislerde dinamik olarak kullanabiliriz.
3-içerisinde kullanacağın bir "product1" isimli service oluştur ve service içerisine de import için "import { HttpClient } from '@angular/common/http'" ekle.
4-Servicein decorator içerisindeki "providedIn:'root'" sil çünkü servicei, global olarak değil de lokal olarak kullanacağız.
5-"HttpClient" de aslında bir servicedir.Bu yüzden service içerisindeki "constructor" metoduna parametre olarak "constructor(@Inject('apiUrl') private apiUrl:string,private http1:HttpClient){}" vermeliyiz.
6-Ardından service içerisinde metod oluşturarak observable objectini çağırırız.Çünkü biz istediğimiz zaman subscribe olabilmek istiyoruz.Mesela:
"getProducts():Observable<Product[]>{
    return this.http1.get<Product[]>(this.apiUrl + 'products').pipe(
      catchError(this.handleError)
    );
}
handleError(err: HttpErrorResponse) {
  let errorMessage = '';
  if (err.error instanceof ErrorEvent) {
     errorMessage = 'Bir hata oluştu' + err.error.message;
     } 
  else {
      errorMessage = 'Sistemsel bir hata';
      }
  return throwError(errorMessage);
}"
7-Daha sonra kullanacağımız componente gelerek "@Component" dekorasyonuna "providers[]" arrayi ekleriz ve içerisine de oluşturduğumuz servicei yazarız.Ayrıca componente bu servicei import da ederiz.
8-Ardından "constructor" metoduna parametre olarak şöyle veririz: "private productService: ProductService".
9-HTMLden çekebilmek ve bu dataları depolamak için, componentte bir object oluşturmamız lazım: "products:Product[]=[]".Böylece service ile çektiğimiz dataları, bunun içerisine yükleyeceğiz.
10-Son olaraksa "ngOnInit" içerisine servisi çağırarak şunu yazarız ve dataları, objecte aktarırız:
"this.productService.getProducts().subscribe((data) => {
  this.products = data;
});"
-------------------------------------------------------------------------------------------------------------
*****HttpClient "service"te "post" kullanmak için:
1-"appModule" içerisine girerek import için "import {HttpClientModule} from '@angular/common/http'" ekle.
2-Ardından da "imports[]" arrayine "HttpClientModule" ekle.Ve "providers[]" arrayını şöyle yap: "providers: [{ provide: 'apiUrl', useValue: 'http://localhost:3000/' }]".Böylece api urlsini, servislerde dinamik olarak kullanabiliriz.
3-içerisinde kullanacağın bir "product1" isimli service oluştur ve service içerisine de import için "import { HttpClient } from '@angular/common/http'" ekle.
4-Servicein decorator içerisindeki "providedIn:'root'" sil çünkü servicei, global olarak değil de lokal olarak kullanacağız.
4-"HttpClient" de aslında bir servicedir.Bu yüzden service içerisindeki "constructor" metoduna parametre olarak "constructor(@Inject('apiUrl') private apiUrl:string,private http1:HttpClient){}" vermeliyiz.
5-Ardından service içerisinde metod oluşturarak observable objectini çağırırız.Çünkü biz istediğimiz zaman subscribe olabilmek istiyoruz.Mesela:
"postProduct(postData:Product):Observable<Product>{
  const httpOptions = {
    headers:new HttpHeaders({
      'Content-Type' : 'application/json',
      'Authorization' : 'Token'
    })
  }
  return this.http.post<Product>(this.apiUrl + 'products',postData,httpOptions).pipe(
    catchError(this.handleError)
  )
}
handleError(err: HttpErrorResponse) {
  let errorMessage = '';
  if (err.error instanceof ErrorEvent) {
    errorMessage = 'Bir hata oluştu' + err.error.message;
  } else {
    errorMessage = 'Sistemsel bir hata';
  }
  return throwError(errorMessage);
}"
6-Daha sonra kullanacağımız componente gelerek "@Component" dekorasyonuna "providers[]" arrayi ekleriz ve içerisine de oluşturduğumuz servicei yazarız.Ayrıca componente bu servicei import da ederiz.
7-Ardından "constructor" metoduna parametre olarak şöyle veririz: "private productService: ProductService".
8-Burada post edeceğimiz "Product" tipindeki datalar için bir container olarak kullanacağımız "product:Product = new Product()" değişkeni oluşturacağız.Post ederken bilgileri, bu değişkene aktarıp ve bu değişkeni post edeceğiz.
9-Post işlemini reactive form üzerinden gerçekleştireceğiz o yüzden önce form oluşturacağız.Mesela "name" ve "email" isteyen şöyle bir form olsun:
"firstFormGroup = this.fb.group({
  name: ['', Validators.compose([Validators.required,Validators.minLength(5),Validators.maxLength(50)])]
})
secondFormGroup = this.fb.group({
  email: ['', Validators.compose([Validators.required,Validators.email,Validators.minLength(5),Validators.maxLength(50)])]
})".
10-Daha sonra htmlde bir butona "onSubmit()" adından fonksiyon atarız ve bu fonksiyonu componentte şöyle çağırırız:
"onSubmit(){
  if(this.firstFormGroup.valid&&this.secondFormGroup.valid){
    this.product = Object.assign(
      {},
      this.firstFormGroup.value,
      this.secondFormGroup.value
    );
    this.productService.postProduct(this.product).subscribe((data) => {
      console.warn(data.name + 'Başarıyla eklendi');
      console.warn(data.email + 'Başarıyla eklendi');
    });
  }
}"
11-Böylece "product:Product" değişkenine "assign" metodu sayesinde, değerleri atadık ve post işlemini bu değişken üzerinden sağladık.
-------------------------------------------------------------------------------------------------------------
*****Activated Route ile "dinamik" parametreyle object çekmek:
1-Bu senaryoda, "cityComponent"te kişiler bulunacak.Biz buradaki şehre tıkladığımızda, "cityDetailComponent" gideceğiz ve kişinin idsini çekeceğiz.
2-Önce "routingModule" git ve path olarak "{path:'city/cityDetail/:cityId', component:CityDetailComponent}" ekle.Buradaki "cityId", bir değişkendir ve urldeki "id" değerlerini belirtecektir ve herhangi bir "cityDetail/x" urlsine girdiğimizde bizi, "cityDetailComponent"e yönlendirecektir.
3-"appModule" içerisine girerek import için "import {HttpClientModule} from '@angular/common/http'" ekle.
4-Ardından da "imports[]" arrayine "HttpClientModule" ekle.Ve "providers[]" arrayını şöyle yap: "providers: [{ provide: 'apiUrl', useValue: 'http://localhost:3000/' }]".Böylece api urlsini, servislerde dinamik olarak kullanabiliriz.
5-Ardından servis yazacağız."city" service oluştur.
6-"HttpClient" de aslında bir servicedir.Bu yüzden service içerisindeki "constructor" metoduna parametre olarak "constructor(@Inject('apiUrl') private apiUrl:string,private http1:HttpClient){}" vermeliyiz.
7-Bulunduğumuz urldeki "id" parametresini almak için şunu yaz:
"getCity(cityId:number):Observable<City>{
  return this.http.get<City>(this.apiUrl + 'cities/' + cityId).pipe(
    catchError(this.handleError)
  )
}
handleError(err: HttpErrorResponse) {
  let errorMessage = '';
  if (err.error instanceof ErrorEvent) {
     errorMessage = 'Bir hata oluştu' + err.error.message;
     } 
  else {
      errorMessage = 'Sistemsel bir hata';
      }
  return throwError(errorMessage);
}
".
4-Böylece belirttiğimiz urldeki "city" objectlerinden, mevcut olduğumuz urlnin idsine göre "city" çekeceğiz.Şimdi "cityDetailComponent"e gel.Hem "CityService" hem "activatedRoute" çağır.
5-Atama yapabilmek için "City" tipindeki "city:City" değişkeni oluştur.
6-"activatedRoute" import et ve "ngOnInit" içerisine de şunu gir:
"this.activatedRoute.params
.pipe(map((params) => params.cityId))
.subscribe((cityId) => {
  this.cityService.getCity(cityId).subscribe((data: City) => {
    this.city = data;
  })
})".
7-Böylece "cityId", bulunduğumuz urlnin "cityDetail/:cityId" kısmındaki yeri çekecektir ve ona göre object döndürerek "city" değişkenine atayacaktır.Artık personı, htmlde şöyle çağırıp yazabiliriz:
""
-------------------------------------------------------------------------------------------------------------
*****CanActivate ile guard yapmak ve LocalStorage ile depolayarak login[auth] olmak:
****Bu senaryoda "NavComponent", "LoginComponent","HomeComponent" ve "AddProductComponent" componentlerimiz olacak."AddProductComponent"e izinsiz erişim olmayacak ve aksi durumlarda otomatik olarak "LoginComponent"e yönlendirilecek:
1-Userları "get" ile çekeceğimiz için öncelikle model oluşturacağız."Models" folderı içerisine "user.ts" şeklinde şöyle oluştur:
"export class User{
  id:number=0;
  username:string="";
  password:string="";
}".
2-"appModule" içerisine girerek import için "import {HttpClientModule} from '@angular/common/http'" ekle.
3-Ardından da "imports[]" arrayine "HttpClientModule" ekle.Ve "providers[]" arrayını şöyle yap: "providers: [{ provide: 'apiUrl', useValue: 'http://localhost:3000/' }]".Böylece api urlsini, servislerde dinamik olarak kullanabiliriz.
4-Ardından bunları servis edecek "account" servisi oluştur."HttpClient" de aslında bir servicedir.Bu yüzden service içerisindeki "constructor" metoduna parametre olarak "constructor(@Inject('apiUrl') private apiUrl:string,private http1:HttpClient){}" vermeliyiz.
5-Serviste userları çekerek, parametre olarak aldığımız userın eşit olup olmadığını şöyle denetle:
"loggedIn:boolean=false;
login(user:User):boolean{
  this.http.get<User[]>(this.apiUrl + 'accounts').pipe(
    catchError(this.handleError)
  ).subscribe((data:User[])=>{
    for(let i=0;i<data.length;i++){
      if(data[i].username==user.username&&data[i].password==user.password){
        this.loggedIn=true;
        localStorage.setItem('isLogged',user.username);                     
      }
    }
    if(this.loggedIn==true){
      this.toastService.showSuccess('Succesfully logged in', 'Congrats!');
      this.router.navigate(['home']);  
    }
    else{
      this.toastService.showError('Login failed', 'Error!');      
    }
  });
  return this.loggedIn;
}
isLoggedIn():boolean{
  return this.loggedIn;
}
logOut(){
  localStorage.removeItem('isLogged');
  this.loggedIn=false;
}
handleError(err: HttpErrorResponse) {
  let errorMessage = '';
  if (err.error instanceof ErrorEvent) {
     errorMessage = 'Bir hata oluştu' + err.error.message;
     }
  else {
      errorMessage = 'Sistemsel bir hata';
      }
  return throwError(errorMessage);
}".
3-Böylece, servisteki auth işlemi doğrulanır ve "loggedIn" "true" olursa "SuccessToast" çalışır ve ardından "home" componente yönlendirir; aksi takdirde "ErrorToast" çalışır.Şimdi guard yazacağız."Login" componentin dizinine gel ve "login" adında guard oluştur.Bu, aslında bir servistir.İçerisine şöyle yaz:
"@Injectable({
  providedIn: 'root',
})
export class LoginGuard implements CanActivate {
  constructor(private accountService: AccountService, private router: Router) {}
  canActivate(
    route: ActivatedRouteSnapshot,
    state: RouterStateSnapshot
  ):
    | boolean
    | UrlTree
    | Observable<boolean | UrlTree>
    | Promise<boolean | UrlTree> {
    let logged = this.accountService.isLoggedIn();
    if (logged) {
      return true;
    }
    this.router.navigate(['login']);
    return false;
  }
}".
4-Böylece artık eğer "logged" true ise "true" döndürecek fakat eğer false ise de "login" pathına yönlendirecek.Böylece kullanıcıyı login ekranına getirecek ve "false" dönecek.
5-"app-routing-module" gir ve şöyle yaz:
"const routes:Routes = [
  {path:'addProduct', component:AddProductComponent,canActivate:[LoginGuard]},  
  {path:'login', component:LoginComponent},
  {path:'home',component:HomeComponent},
  {path:'**',redirectTo:'home',pathMatch:'full'}
]".
6-Böylece guardımızı "AddProduct" componente ekledik ve onu koruduk.Şimdi "login" hmtline gel ve şöyle bir form gir:
"<main class='form-signin'>
<form [formGroup]='form1'>
  <div class='d-flex align-items-center justify-content-center'>
    <img class='mb-4 mx-auto' src='https://images.unsplash.com/photo-1624455806586-037944b1fa1a?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=580&q=80' alt='' width='72' height='57'>
  </div>
  <h1 class='h3 mb-3 fw-normal'>Please sign in</h1>

  <div class='form-floating'>
    <input formControlName='name1' type='text' class='form-control' id='floatingInput' placeholder='Your Name'>
    <label for='floatingInput'>Name</label>
  </div>
  <div class='form-floating'>
    <input formControlName='password1' type='password' class='form-control' id='floatingPassword' placeholder='Password'>
    <label for='floatingPassword'>Password</label>
  </div>
  <button (click)='onSubmit()' class='w-100 btn btn-lg btn-primary' type='submit'>Sign in</button>
  <p class='mt-5 mb-3 text-muted'>&copy; 2017–2021</p>
</form>
</main>
<div *ngIf='spinner' style='position: absolute;top: 50%;right: 50%;' class='spinner-border' role='status'>
</div>".
7-Artık form oluşturduk ve "login" componente gelerek hem reactive form içeriğini yaz hem de butona tıklayınca "account" servisle iletişime geçeceğiz.Şöyle:
"constructor(private fb:FormBuilder,private accountService:AccountService) { }
model:User = new User();
spinner!:boolean;
form1 = this.fb.group({
  name1:["",Validators.required],
  password1:["",Validators.required]
})
onSubmit(){
  this.spinner=true;
  this.model.username=this.form1.get('name1')?.value;
  this.model.password=this.form1.get('password1')?.value;
  this.authService.login(this.model);
  this.spinner=false;
}".
8-Böylece tıklandığı zaman form ögelerini "User" tipindeki "model" objectine atadık ve "model" objectini servise gönderdik.Servis kontrol edecek ve boolean döndürecek.
9-Artık istediğimiz componentten servisi çekerek, servisteki "isLoggedIn()" boolean fonksiyonunu çağırarak kullanıcının login olup olmadığını kontrol ederiz.Hatta servisin 
"logOut()" fonksiyonuyla da LocalStoragedaki kaydı silerek logout yaparız.Biz bunları navda kullanacağımızdan dolayı "NavComponent" gel.
10-"Nav" componentin Htmline şöyle ekle:
"<li><a *ngIf='isLoggedIn()==false' routerLink='login' routerLinkActive='active1'>Login</a></li>
<li><a (click)='logOut()' *ngIf='isLoggedIn()==true' routerLink='city'>Logout</a></li>".
11-Ardından componentine gel ve contructorda servisi şöyle injekt et :"constructor(private authService:AuthService) { }".
12-Şimdi ise htmlde tanımlanan fonksiyonları, componentte şöyle çağır:
"isLoggedIn(){
  return this.authService.isLoggedIn();
}
logOut(){
  return this.authService.logOut();
}".
13-Böylece login olunca bu değer "true" olacak ve "logOut" elementi çalışacak.Aksi takdirde "login" elementi çalışacak.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
*****Auth0 ve OpenId ile SSO login yapmak ve guard yaparak da kullanıcı, login olmadığında componentlere erişmek isterse; anasayfaya yönlendirmek:
****Bu senaryoda elimizde "NavComponent","AboutComponent" "HomeComponent" bulunacak ve SSO ile bu navın ve homeun bazı bölümlerini korumaya alacağız ve aboutı homea yönlendireceğiz.
1-Öncelikle "npm i angular-oauth2-oidc --save" azarak OAuth yükle."npm i angular-oauth2-oidc-jwks --save" yazarak da "jwk" yükle.
2-"app.module" gel ve "import { OAuthModule } from 'angular-oauth2-oidc';import {HttpClientModule} from '@angular/common/http';" import et ve 
"imports[OAuthModule.forRoot(),HttpClientModule]" şeklinde de ekle.
3-Ardından "AppComponent" dizinine gel ve "sso.config.ts" oluştur.İçerisine şu configurationu ekle:
"import { AuthConfig } from 'angular-oauth2-oidc';
export const authCodeFlowConfig: AuthConfig = {
  // Url of the Identity Provider
  issuer: 'https://idsvr4.azurewebsites.net',
  // URL of the SPA to redirect the user to after login
  redirectUri: window.location.origin + '/city',
  // The SPA's id. The SPA is registerd with this id at the auth-server
  // clientId: 'server.code',
  clientId: 'spa',
  // Just needed if your auth server demands a secret. In general, this
  // is a sign that the auth server is not configured with SPAs in mind
  // and it might not enforce further best practices vital for security
  // such applications.
  // dummyClientSecret: 'secret',
  responseType: 'code',
  // set the scope for the permissions the client should request
  // The first four are defined by OIDC.
  // Important: Request offline_access to get a refresh token
  // The api scope is a usecase specific one
  scope: 'openid profile email offline_access api',
  showDebugInformation: true,
}".
4-Artık configurasyonunu yaptığımız bu servisi istediğimiz zaman "authCodeFlowConfig" olarak çağırabiliriz.Şimdi ise "Nav" htmline gel ve şöyle yaz:
"<ul *ngIf='token' style='display: inline-block;'>
<li><a routerLink='city' routerLinkActive='active1'>Home</a></li>
<li><a routerLink='about' routerLinkActive='active1'>About</a></li>
<li><a routerLink='cityadd' routerLinkActive='active1'>Add City</a></li>
<li><a routerLink='cityremove' routerLinkActive='active1'>Remove City</a></li>
</ul>
<ul style='display: inline-block;'>
<li><button *ngIf='!token' (click)='ssoLogin()' routerLinkActive='active1'>SSO Login</button></li>
<li><button *ngIf='token' (click)='ssoLogout()' routerLinkActive='active1'>SSO Logout</button></li>
</ul>".
5-Böylece navın üst kısmı, sadece "token" mevcutken görünecektir."token" yokken "login"; varken de "logout" görünecektir.Şimdi "Nav" componente gel ve servisi 
"import {OAuthService} from 'angular-oauth2-oidc'" şeklinde import et.
6-"Nav" componenti şöyle yaz:
"constructor(private oauthService:OAuthService) {
  this.configureSingleSignOn();
 }
configureSingleSignOn(){
  this.oauthService.configure(authCodeFlowConfig);
  this.oauthService.tokenValidationHandler = new JwksValidationHandler();
  this.oauthService.loadDiscoveryDocumentAndTryLogin();
}
ssoLogin(){
  this.oauthService.initImplicitFlow();
}
ssoLogout(){
  this.oauthService.logOut();
}
get token(){
  let claims:any = this.oauthService.getIdentityClaims();
  return claims ? claims : null;
}".
7-Böylece kullanıcı, sayfadaki "login" butonuna basarak login olmadan, içeriklere erişemez.Eğer başka componentlerde de tokenı elde edip ona göre içerik gizlemek istiyorsak, mesela "HomeComponent"e geçelim.
8-"contrusctor" içerisinde "private oauthService:OAuthService" çağır ve componenti şöyle yaz:
"get token(){
  let claims = this.oauthService.getIdentityClaims();
  return claims ? claims : null;
}".
9-Böylece tokenı "home" içerisinde tespit edebileceğiz."home" componenti komple saklamak için htmlini şöyle yaz:
"<div *ngIf='token; else #loginError'>
<p>Welcome Home Component!</p>
</div>
<ng-template #loginError>You must login to see content!</ng-template>".
10-Böylece artık token yoksa, error mesajı görebilecektir.Şimdi ise guard yaparak kullanıcı, urlden "about" componentini yazdığında eğer token yoksa "home" componentine yönlendireceğiz.
11-"guards" folderı içerisine "login.guard" ekle ve şöyle yaz:
"constructor(private router: Router,private oauthService:OAuthService) {}
canActivate(
  route: ActivatedRouteSnapshot,
  state: RouterStateSnapshot): Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree {
    let claims = this.oauthService.getIdentityClaims();
    if (claims) {
      return true;
    }
    this.router.navigate(['city']);
    return false;
}".
12-Ardından "app.routing.module" gel ve "about" componentini korumak için şöyle yaz:
"{path:'about',component:AboutComponent,canActivate:[LoginGuard]}".
13-Böylece about componentine tokensız erişmek isteyen kullanıcılar, otomatik olarak "city" componentine yönlendirilecek ve "city" componentinde de error mesajı görecektir.
14-Eğer kullanıcıyı doğrudan SSO loginine yönlendirmek istiyorsak, Nav component gel ve şöyle yap:
"<ul *ngIf='token' style='display: inline-block;'>
<li><a routerLink='city' routerLinkActive='active1'>Home</a></li>
<li><a routerLink='about' routerLinkActive='active1'>About</a></li>
<li><a routerLink='cityadd' routerLinkActive='active1'>Add City</a></li>
<li><a routerLink='cityremove' routerLinkActive='active1'>Remove City</a></li>
</ul>".
15-Ardından da "Nav" componenti şöyle düzenle:
"constructor(private oauthService:OAuthService) {
  this.configureSingleSignOn();
 }
configureSingleSignOn(){
  this.oauthService.configure(authCodeFlowConfig);
  this.oauthService.tokenValidationHandler = new JwksValidationHandler();
  this.oauthService.loadDiscoveryDocumentAndLogin();
}
get token(){
  let claims:any = this.oauthService.getIdentityClaims();
  return claims ? claims : null;
}".
16-Böylece kullanıcı, doğrudan SSO sayfasına gidecek ve giriş işleminin ardından siteye dönecek."token" ise, cache temizlenene kadar kullanıcının browserında tutulacaktır.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
*****"router" modülü ile statei kaybetmeden sayfa yönlendirmesi yapmak:
1-Mesela html kısmında şöyle bir button olsun "<button (click)='router1()'></button>".
2-Componente gel."contructor(private router:Router){}" şeklinde inject et ve şöyle yaz:
"router1(){
  this.router.navigate(['home']);
}"
3-Böylece path olarak "/home" olarak yönlendirmiş olduk.
--------------------------------------------------------------------------------------------------------------
*****Urlyi string olarak çekmek için:
1-Componente gelerek "constructor(private router:Router){}" ekle ve şöyle yaz:
"console.log(this.router.url)".
--------------------------------------------------------------------------------------------------------------
*****Routelarda hiyerarşik navigasyonlar:
1-Absolute routea geçiş için:
"<button [routerLink]="['/home']">Go DOWN</button>".
2-Parent routea geçiş için, mesela bulunduğumuz mevcut url 'localhost:4200/home/login' olsun:
"<button [routerLink]="['../../home']">Go UP</button>".
3-Sibling routea geçiş için, mesela bulunduğumuz mevcut url 'localhost:4200/home/login' olsun:
"<button [routerLink]="['../register']">Go SIBLING</button>".
4-Child routea geçiş için, mesela bulunduğumuz mevcut url 'localhost:4200/home' olsun:
"<button [routerLink]="['./login']">Go DOWN</button>".
5-Eğer üstteki işe yaramazsa, child routea geçiş için, mesela bulunduğumuz mevcut url 'localhost:4200/home' olsun:
"<button [routerLink]="['login']">Go DOWN</button>".
----------------------------------------------------------------------------------------------------------------
*****Nested routelar tanımlamak için:
1-Mesela 'localhost:4200/home' routeu için bir component ve bu routeun childları için de birer component atayalım."app-routing-module" gel:
"const routes: Routes = [
  {path:'home', children:[
    {path:'', component:HomepageComponent},           /home
    {path:'login', component:LoginComponent},         /home/login
    {path:'register', component:RegisterComponent}    /home/register
  ]},
  {path:'', redirectTo:'home',pathMatch:'full'},
  {path:'**',component:NotfoundComponent}];".
----------------------------------------------------------------------------------------------------------------
*****Routerlara "name" vererek aynı path içerisinde farklı outlerler aktif etmek için:
1-Htmle gel ve şöyle yaz:
"<router-outlet></router-outlet>
<router-outlet name='test1'></router-outlet>".
2-"app-routing.module" gel ve şöyle belirt:
"{path:'home', children:[
  {path:'', component:HomepageComponent},
  {path:'', component:SidePageComponent, outlet:'test1'},
]},
{path:'', redirectTo:'home',pathMatch:'full'},
{path:'**',component:NotfoundComponent}".
3-Böylece "localhost:4200/home" pathında iki component birden aktif olacaktır.
----------------------------------------------------------------------------------------------------------------
*****Farklı routeları aynı componentlere atamak için:
1-Htmle gel ve şöyle yaz:
"<router-outlet name='main_outlet1'></router-outlet>
<router-outlet name='test_outlet1'></router-outlet>".
2-"app-routing.module" gel ve şöyle belirt:
"const routes: Routes = [
  {path:'home', children:[
    {path:'', component:HomepageComponent, outlet:'main_outlet1'},
    {path:'', component:ModalComponent, outlet:'test_outlet1'},
  ]},
  {path:'login', children:[
    {path:'', component:HomepageComponent, outlet:'main_outlet1'},
    {path:'', component:ModalComponent, outlet:'test_outlet1'},
  ]},
  {path:'', redirectTo:'home',pathMatch:'full'},
  {path:'**',component:NotfoundComponent}];".
3-Böylece bu iki component de "localhost:4200/home" ve "localhost:4200/login" routelarında aktif olacaktır.
----------------------------------------------------------------------------------------------------------------
*****Lazy loading routelar yapmak için:
1-"app.routing.module" gel ve şöyle yap:
"const routes : Routes[
  { path:'home', loadComponent: () => import('./components/home.component').then((c)=>c.HomeComponent) }
  { path:'login', title : 'Login', component:LoginComponent }
]".
----------------------------------------------------------------------------------------------------------------
*****Spesifik routelar için spesifik "title"lar belirlemek:
1-"app.routing.module" gel ve şöyle yap:
"const routes : Routes[
  { path:'home', title : 'Homepage', loadComponent: () => import('./components/home.component').then((c)=>c.HomeComponent) }
  { path:'login', title : 'Login', component:LoginComponent }
]".
----------------------------------------------------------------------------------------------------------------
*****Sıfırdan, en baştan "rout" yapmak için:
1-"app" içerisine bir "app-routing-module.ts" classı oluştur.Fakat içerisini şöyle editleriz:
"const routes:Routes = [
  {path:'login', component:LoginComponent},
  {path:'**',redirectTo:'login',pathMatch:'full'}
];
@NgModule({
  declarations: [],
  imports: [
    RouterModule.forRoot(routes)
  ],
  exports:[RouterModule]
})
export class AppRoutingModule { }".
2-"appModule" git ve "imports[]" arrayi içerisine, oluşturduğumuz "AppRoutingModule" ekle.
5-HTML içerisinde kullanmak için de "<router-outlet>" tagını kullanırız.
--------------------------------------------------------------------------------------------------------------
*****Reactive Formlar için:
1-Componente gir ve "import{FormControl,FormGroup} from '@angular/forms'" modüllerini import et.
2-Tekli binding[componentten çekerek] için önce bir değişkene "FormControl" objecti tanımla.Mesela: 
"name1 = new FormControl('')".
3-Ardından bind edilecek inputa bu değişkeni çağır.Mesela: "<input [formControl]='name1'>".Artık HTML içerisinde istediğimiz yere "{{name1.value}}" şeklinde bind edebiliriz.
4-Grup tanımları[veya nested gruops] için önce bir değişkene "FormGroup" objecti tanımla ve objectin içerisine de <input> taglarının içerisine atayacağın değişkenleri tanımla.Mesela:
"form1 = new FormGroup({
    firstName : new FormControl(''),
    lastName : new FormControl(''),
    skills: new FormGroup({
        skillName: new FormControl(''),
        experience: new FormControl(''),
    })
})"
5-Daha sonra hem form tagına grup değişkenini tanımla hem de form içerisindeki inputlara objectin içerisindeki değişkenleri tanımla.Nested gruplar için de "formGroupName" kullan.Mesela:
"<form1 [formGroup]='form1'>
<input formControlName='firstName'>
<input formControlName='lastName'>
<div formGroupName='skills'>
<input formControlName='skillName'>
<input formControlName='experience'>
</div>
</form1>"
6-Artık inputlara girilen valuelerle grup içerisindeki değişkenleri bağladık.Şimdi konsolda görüntülemek içinse butona "click" eventi veya "<form>" tagına "ngSubmit" fonksiyonu atarız.Mesela: "<form (ngSubmit)='function1()'>"
7-Componente gel ve "function1()" metodunu "value" propertisiyle şöyle çağır:
"function1(){
    console.log(this.form1.value);
}"
8-Tanımlı form değişkenlerine bir sürü property atayabiliriz.Bunlardan bazıları:
-value= Form inputlarının "submit" edilirkenki değerlerini gösterir."console.log(this.form1.value)".
-status= Formu, submit edilirken "valid" veya "invalid" döndürür."console.log(this.form1.status)".
-get= Form içerisinde belirtilen kontrol elemanlarını döndürür.Mesela:
"console.log(return this.form1.get('firstName'))"
-get[nestedGrup] = Form içerisindeki nested grup kontrol elemanlarını döndürür.Mesela:
"console.log(return this.form1.get('skills')?.get('skillName'))"
-push = Form grubundaki "FormArray" arrayindeki aliaslara eleman ekler.Öncesinde "get getAlias()" ile isimsiz alias grubunu çekeriz.Bu metod, aliasları Array olarak döndürecek ve biz de bu metodu çağırırız.Mesela:
"addAlias(){this.getAliases.push(this.fb.control(''))}"
9-Formun tüm elemanları "valid" olana kadar, butonların "disabled" olmasını şöyle sağlarız:
"<button (click)='function1()' [disabled]='!form1.valid' type='submit'>test</button>"
10-Forma entegre ettiğimiz valueleri değiştirmek için "setValue()" metodu gerekli.Normal binding değişkenlerini direk çağırabiliriz fakat gruba ait form değişkenlerini çağırmak içinse şöyle kullanırız:
"function1(){
    this.name1.setValue('turşu1');  //tekliFormControl
    this.form1.setValue({           //FormGroup
      firstName:'turşu2',
      lastName:'turşu3',
      skills: {
          skillName: 'turşu4',
          experience: 'turşu5'
      }
    });
}"
11-Value değiştirmek için "patchValue()" metodunu da kullanabiliriz.Aradaki fark şudur: "setValue" kullanıyorsak, formun tanımlanmış bütün elemanlarını yazmak ve kullanmak zorundayız; fakat "patchValue", bütün elemanları yazmaya gerek kalmadan bize, tek tek value değişimleri de sağlıyo.
12-"Validator" tanımlarını yaparken de değişkenleri tanımlarken yaparız.Bunlardan bazıları:
-"name1 = this.fb.control('',Validators.required)".
-"name1 = this.fb.control('',Validators.maxLength)".
-"name1 = this.fb.control('',Validators.minLength)".
-"name1 = this.fb.control('',Validators.forbiddenNameValidator(/john/i))".  //RegExp
-"name1 = this.fb.control('', Validators.compose([Validators.required,Validators.minLength(5),Validators.maxLength(50)]))".  //Multiply
13-Directivelerle "RegExp" oluşturarak Validationlar için, önce Directive oluştur.
14-Custom Validator da oluşturup, mesela register formlarda 2 adet şifrenin birbiriyle eşlenip eşlenmediğini şöyle sağlarız:
"form1 = this.fb.group(
  {name1 : ['',Validators.required],
  password1 : ['',Validators.required],
  password2 : ['',Validators.required]},
  {Validator:this.passwordMatcher1})
passwordMatcher1(g:FormGroup):boolean{
  return g.get('password1')?.value === g.get('password2')?.value?null:{mismatch:true};
}".
15-"FormBuilder" kullanarak da grup form değişkenleri tanımlarken her defasında "FormControl" veya "FormGroup" kullanmaktan kurtuluruz."constructor(private fb1:FormBuilder)" ekle ve import et.
16-Ardından çok daha sade bir biçimde yazabileceğiz.Mesela 4. adımdaki nested grupları tekrar yazalım:
"form1 = this.fb1.group({
  firstName:['',Validators.required],
  lastName:['',Validators.required],
  skills:this.fb1.group({
    skillName:['',Validators.required],
    experience:['',Validators.required]
  })
})"
17-Tekli form değişkenini "FormBuilder" ile şöyle yazarız: "name1 = this.fb.control('',Validators.required)".
18-İsimlendirilmemiş form control elemanlarını yönetmek için "import {FormArray} from '@angular/forms'" import ederiz.
19-Bu isimsiz form elemanları için "control()" metoduyla genel bir "alias" şöyle belirtiriz:
"form1 = this.fb1.group({
    firstName:['',Validators.required],
    lastName:['',Validators.required],
    skills:this.fb1.group({
      skillName:['',Validators.required],
      experience:['',Validators.required]
  }),
  aliases: this.fb1.control([
      this.fb1.control('',Validators.required);
  ]);
})"
20-Bu "aliases" kontrol arrayine "push" metoduyla yeni elemanlar ekleyebiliriz.Böylece mesela bu metodu bir butona atayarak, her tıklamada form için yeni bir eleman ekletebiliriz:
"addAlias() {
    this.aliases.push(this.fb.control(''));
}"
21-İsimsiz form elemanlarını array içerisinde tuttuğumuz için, HTML'de "ngFor" ile çağırmak en doğrusudur."formArrayName" kullanarak içerisine toplarız.Ayrıca "[formControlName]" ile inputa atayarak index numarasına eşitleriz her bir inputu.Mesela:
"<form1 [formGroup]='form1'>
<input formControlName='firstName'>
<input formControlName='lastName'>
<div formGroupName='skills'>
<input formControlName='skillName'>
<input formControlName='experience'>
</div>
<div formArrayName='aliases'>
<button (click)='addAlias'>+Add Aliases!</button>
<div *ngFor='let alias of aliases.controls; let i=index'>
<input [formControlName]='i'>
</div>
</div>
</form1>"
22-Form elemanlarını oluştururken, bütün hepsine "get" metodu atarız ki submit edildikten sonra valueleri çekebilelim.Nested grupları çekerken de hiyerarşik olarak sırayla "get" ile art arda çekeriz.Mesela:
"get getForm1(){
  return this.form1.value;
}
get getFirstname(){
    return this.form1.get('firstName');
}
  get getLastname(){
    return this.form1.get('lastName');
}
  get getSkillname(){
    return this.form1.get('skills')?.get('skillName');
  get getExperience(){
    return this.form1.get('skills')?.get('experience');
}
  get getAliases(){
    return this.form1.get('aliases')?.value as FormArray;
}"
23-Daha sonra form elementine "<form (ngSubmit)='function1()'>" atarız ve get metodlarını çağırırken "value()" metoduyla konsolda şöyle görüntüleriz:
"console.log(this.getForm1);
console.log(this.getAliases?.value);
console.log(this.getFirstname?.value);
console.log(this.getLastname?.value);
console.log(this.getSkillname?.value)
console.log(this.getExperience?.value);"
24-Form inputlarının mevcut statülerine göre "*ngIf" içerisine bazı classlar tanımlarız.Belirtilen inputun "formControlName"ini kullanan "get" metodlarını çekerek kullanırız ki; böylece hangi inputa bağlı çalışacağını biliriz.Bazıları:
-ng-valid= Geçerli olup olmadığını kontrol eder.
-ng-invalid= Geçerli olup olmadığını kontrol eder.
-ng-pending= Eğer form, gönderilebilme durumundaysa gerçekleşir.
-ng-pristine= Kullanıcı, herhangi input girmediği sürece geçerlidir.
-ng-dirty= Kullanıcı, input girdikten itibaren devamlı geçerlidir.
-ng-untouched= Sadece focus kaybetmediği sürece geçerlidir.
-ng-touched= Focus aldıktan sonra focusu kaybederse geçerlidir.
-ng-submitted= Submit edildiğinde gerçekleşir.
-En genel kullanımı:
"<input formControlName='firstname1'><div *ngIf='firstname1.invalid&&(firstname1.dirty||firstname1.touched)'></div>"
-Üsttekine alternatif:
"<input formControlName='firstname1'><div *ngIf='firstname1.errors&&(firstname1.dirty||firstname1.touched)'></div>"
-En genel style kullanımı:
"<input formControlName='lastname1'><div [style.visibility]='(lastname1?.invalid)||(lastname1?.dirty&&lastname1?.touched))?'visible':'hidden''></div>"
-"hasError" ile "required" kullanımı[tabi Validators ile önceden tanımlanmış olmaları gerek]:
"<input formControlName='firstname1'><div *ngIf='firstname1.hasError('required')&&(firstname1.dirty||firstname1.touched)'></div>"
-"hasError" ile "minLength()" kullanımı[tabi Validators ile önceden tanımlanmış olmaları gerek]:
"<input formControlName='firstname1'><div *ngIf='firstname1.hasError('minlength')&&(firstname1.dirty||firstname1.touched)'></div>"
-Multiply kullanımı:
"<p *ngIf='(name1?.hasError('minlength')&&!(name1?.hasError('required'))&&!(name1?.hasError('maxlength'))&&(name1?.dirty||name1?.touched))'>Max.50 Karakter!</p>"
-"mismatch" ile kullanımı[formun kendisini çeker controller çekmez]:
"<p *ngIf='form1.hasError('mismatch')&&(password1.dirty||password1.touched)'>Şifreler uyumsuz!</p>
<p *ngIf='form1.hasError('mismatch')&&(password2.dirty||password2.touched)'>Şifreler uyumsuz!</p>"
-------------------------------------------------------------------------------------------------------------
*****"ngFor" directive özellikleri:
1-Object içerisinde gezinmek için mesela:
"<li *ngFor='let user of users'>{{users.length}}.{{user}}</li>".
2-Object içerisinde gezinirken, her loopu "index" ile takip etmek için:
"<li *ngFor='let user of users; index as i'>{{i}}/{{users.length}}.{{user}}</li>".
3-Object içerisinde gezinirken, "ilk" ve "son" loopu takip etmek için:
"<li *ngFor='let user of users; index as i; first as first1; last as last1'>
{{i}}/{{users.length}}.{{user}}
<span *ngIf='first1'>TEXT</span>
<span *ngIf='last1'>TEXT</span>
</li>".
4-Object içerisinde gezinirken, her looptaki "tek" ve "çift" indexleri takip etmek için:
"<li *ngFor='let user of users; odd as odd1; even as even1'>
{{users.length}}.{{user}}
<span *ngIf='odd1'>TEXT</span>
<span *ngIf='even1'>TEXT</span>
</li>".
5-Object içerisinde gezinirken, toplam kaç defa loop olduğunu belirlemek için:
"<li *ngFor='let user of users; count as count1'>
{{users.length}}.{{user}}
<span>{{count1}}</span>
</li>"
-------------------------------------------------------------------------------------------------------------
*****"ngIf" directive özellikleri:
1-Bir yapıyı, bir conditiona göre göstermek için:
"<div *ngIf='user==true'>TEXT</div>"
2-Bir yapıyı, bir conditiona göre gösterip, sonra conditionun aksine göre de bir "template" belirlemek için:
"<div *ngIf='user==true; else span1'>TEXT</div>
<ng-template #span1></ng-template>"
***"else" ve "then" conditionları sadece "ng-template"ler üzerinde UYGULANABİLİR!
3-Eğer componentte local olarak bir değişken tutuyorsak, bununla şöyle condition sağlarız:
"<div *ngIf='condition as value1; else elseBlock'>{{value1}}</div>
<ng-template #elseBlock>Will show when value1 is null</ng-template>" 
4-Componentte "show=false" adında boolean tutalım ve bunu, html içerisinde elemente condition olarak atalım ve bunu da buton sayesinde değiştirelim ve ayrıca "false" durumlar için alternatif bir "ng-template" kuralım:
"<button (click)='show=!show'>TIKLA</button><span>{{show}}</span>
<div *ngIf='show; else temp1'>Show if true</div>
<ng-template #temp1>Show if false</ng-template>"
5-Üstteki örnekteki gibi componentte bir "show=false" booleanı tutalım ve ek olarak "then" conditionu da ekleyelim:
"<button (click)='show=!show'>TIKLA</button><span>{{show}}</span>
<div *ngIf='show; then temp1 else temp2'>Here is IGNORED</div>
<ng-template #temp1>Show if true</ng-template>
<ng-template #temp2>Show if false</ng-template>"
-------------------------------------------------------------------------------------------------------------
*****Style normal ve conditional kullanımı:
1-Birden fazla css aynı anda uygulamak için mesela:
"<div [ngStyle]='{'backgroundColor':'red','fontSize':'10px','fontSize':'700'}'></div>"
2-Conditional ternary olara uygulamak için:
"<div [ngStyle]='{'fontWeight': (i%2 ? '600':'900'),'fontSize': (i==2 ? '12px':'24px')}'></div>".
3-Eğer üstteki condition çalışmıyorsa bunu dene:
"<div [style.color]='boolean1?'black':'white''></div>".
4-Multiple conditional ternary için:
"<button [ngStyle]='{'backgroundColor':(buttonColor=='mavi'?'blue':buttonColor=='kirmizi'?'red':'initial')}'>Colorful Button</button>"
5-Bu kullanım türünü normal olarak da kullanabiliriz:
"<div [style.fontSize]='22px'></div>".
-------------------------------------------------------------------------------------------------------------
*****Class normal ve conditional kullanımı:
1-Birden fazla class aynı anda uygulamak için:
"<div [ngClass]='{'text-danger':boolean1,'bg-dark':boolean2}'>123</div>"
2-Sadece classlar eklemk için:
"<span [ngClass]="'text-danger bg-dark'">123</span>"
3-Birden fazla classı tek bir conditionla eklemek için:
"<div [ngClass]='{'text-danger bg-dark':boolean1}'>123</div>"
4-Spesifik olarak classlar ekleyebiliriz:
"<div [class.text-danger]='boolean1'>123</div>"
5-Ternary içinse:
"<div [ngClass]='boolean1?'text-danger':'bg-dark''>123</div>".
6-Multiple ternary içinse:
"<p [ngClass]="type=='mavi'?'bg-blue-900':type=='kirmizi'?'bg-red-900':'initial'" *ngFor='let type of buttonTypes'>Color: {{type}}</p>".
7-Multiple class ve multiple ternary örneği:
"<p [ngClass]="odd?['bg-blue-900', 'text-white']:even?['bg-red-900', 'text-white']:'initial'" *ngFor='let type of buttonTypes; odd as odd; even as even'>Color: {{type}}</p>"
-------------------------------------------------------------------------------------------------------------
*****Attribute normal ve conditional kullanımı:
1-Tekli attribute değişimi:
"<div [attr.draggable]='boolean1'>123</div>"
2-Spesifik attributeler için:
"<img [attr.height]='boolean1?'300px':'500px''>".
-------------------------------------------------------------------------------------------------------------
*****Routerlink normal ve conditional kullanımı:
1-Tek statik adrese yönlendirmek için:
"<a routerLink='/Home' routerLinkActive='active'></a>"
2-Dinamik adrese yönlendirmek için:
"<a [routerLink]='city.id' routerLinkActive='active'></a>"
3-Üstteki olmazsa bunu dene:
"<a routerLink='{{city.id}}' routerLinkActive='active'></a>"
4-Ternary için:
"<a [routerLink]='x=='Home'?'/home':'/about'' routerLinkActive='active'></a>".
5-Multiple condition için:
"<a [routerLink]='x=='Home'?'/home':x=='About'?'/about':x=='HOW TO'?'/howto':null'></a>"
-------------------------------------------------------------------------------------------------------------
*****Server-side rendering:
1-Normalde browserda request atınca, browser html, css ve js dosyalarını çeker ve renderlar.Bulunduğun sayfada, kullanılan html içeriğini "view page source" ile görebiliriz.Fakat burada, serverda tüm site datalarını tutacağız.Request gelince, tüm hepsini yükleyecek.İlk sayfa yüklemede zorlanabilir fakat ardından siteyi dolaşırken çok rahat edecektir.Proje dizinindeyken terminali aç ve "ng add @nguniversal/express-engine" yaz.
2-"npm run dev:ssr" koduyla applikasyonumuzu server side renderlayacak ve live reload şeklinde browserda görüntüleyebileceğiz.Eğer işleme olmazsa, önce "npm run build:ssr" yap ve ardından "npm run dev:ssr" yap.
3-Kullanırken dikkat et!Herhangi DOM manipülasyonu yapılamaz.Dom manipülasyonu içeren library[mesela jquery] veya framework kullanılamaz!Componentlerimizde "window, document, navigator, location,.." gibi objectleri kullanamayız.Browsera bağlı olarak çalışan bazı özellik ve yapılara da izin yoktur: "setTimeOut, setInterval, localStorage, sessionStorage,..".
4-Hangi kodun serverda çalışıp hangisinin browserda çalışacağının ayrımını component içerisinde şöyle yaparız:
"constructor(@Inject(PLATFORM_ID) private platformId: Object) { }
ngOnInit() {
  if (isPlatformBrowser(this.platformId)) {
    //Tarayıcıda çalışacak kodlar...
  }
  if (isPlatformServer(this.platformId)) {
    //Sunucuda çalışacak kodlar...
  }
}".
5-"ng build && ng run appName:server" komutundaki "appName", bizim aplikasyonumuzun ismidir.Bu komut, projeyi deploy etmek için build eder.Böylece hem server scriptini hem de aplikasyonu "production mode"da çalıştırır.
6-"npm run serve:ssr" komutu aplikasyonu, server-side renderingle lokal olarak servis etmek için server scriptini başlatır.Ayrıca "ng run build:ssr" komutu tarafından oluşturulan build artifactlerini kullandığından dolayı bu komutu da kullanmalıyız."serve:ssr" komutu aplikasyonu, sadece local olarak test etmek için kullanılır.
7-"npm run prerender" komutu, bir aplikasyonun sayfalarını "prerender" etmek için kullanılır.Dinamik sayfaların "build" sırasında işlendiği ve statik HTML olarak oluşturulduğu süreçtir.Dinamik routelar da renderlanacaktır.Bu komutun çalıştığı esnada ek olarak routelar eklemek için şunu kullan: 
"ng run <app-name>:prerender" veya "ng run <app-name>:prerender --routes /product/1 /product/2".Burada "product" componentine statik routelar verdik.
-------------------------------------------------------------------------------------------------------------
*****Dynamic Meta Title için:
1-"index.html" içerisine default bir meta title ekle.Mesela: "<title>City Guide and Person Guide</title>".
2-Sonra her component için ayrı ayrı title belirleyebiliriz.Mesela sitenin "home" componentine gel."constructor" içerisine de "private title:Title" şeklinde servisi inject et.
3-Ardından "ngOnInit" içerisine gel ve bu servisi çekerek titleı şöyle editle: 
"this.title.setTitle('Here is the İstanbul!')".Artık kullanıcı, her "home" componente geldiğinde titleı dinamik olarak değişecek.
-------------------------------------------------------------------------------------------------------------
*****Dynamic Meta Description için:
1-"index.html" içerisine default bir meta description ekle.Mesela: "<meta name='description' content='You can search any discover many famouse people from our website!'>"
2-Sonra her component için ayrı ayrı description belirleyebiliriz.Mesela sitenin "home" componentine gel."constructor" içerisine de "private meta:Meta" şeklinde servisi inject et.
3-Ardından "ngOnInit" içerisine gel ve bu servisi çekerek titleı şöyle editle: 
"this.title.UpdateTag({'description','Lets change our topic!'})".Artık kullanıcı, her "home" componente geldiğinde titleı dinamik olarak değişecek.
-------------------------------------------------------------------------------------------------------------
*****Compodoc:
1-Local yükleme için "npm install --save-dev @compodoc/compodoc" yaz.
2-"package.json" gir ve "scripts" objecti içerisine "compodoc": "npx compodoc -p tsconfig.doc.json" ekle.Böylelikle "node_modules" içerisine eklediğimiz compodocu belirttik ve projeye ekledik.
3-Projenin içerisine[en üst folde levelına] "tsconfig.doc.json" adında bir file oluştur ve bu jsonın içerisine şunu ekle:
"{
  'include': ['src/**/*.ts'],
  'exclude': ['src/test.ts', 'src/**/*.spec.ts', 'src/app/file-to-exclude.ts']
}".
5-"compodoc src -p tsconfig.doc.json" yaz.Eğer olmazsa "compodoc -p tsconfig.doc.json" yaz.
6-"compodoc -p tsconfig.doc.json -s" yaz ve karşımızda açılacak.
-------------------------------------------------------------------------------------------------------------
*****Lite-server:
1-"npm install lite-server --save-dev" ile yükleyelim projemize.
2-"package.json" içerisindeki "scripts" objecti içerisine "'dev': 'lite-server'" ekle.
3-Ayağa kaldırmak için "npm run dev" yaz.
-------------------------------------------------------------------------------------------------------------
*****ng-mocks:
1-"npm install ng-mocks --save-dev" yaz.
2-"src" içerisindeki "test.js" içerisine gel ve "import { MockInstance, ngMocks } from 'ng-mocks'" import et.
3-Ardından içerisine şunları ekle:
"ngMocks.autoSpy('jasmine');
jasmine.getEnv().addReporter({
  specDone: MockInstance.restore,  specStarted: MockInstance.remember,  suiteDone: MockInstance.restore,  suiteStarted: MockInstance.remember,
})".
4-BUNU ANLAMADIM!
-------------------------------------------------------------------------------------------------------------
*****Nx:
1-"npm install -g @angular/cli" yazarak CLI güncelle."npm install -g @nrwl/schematics" yazarak da chematics yükle.
2-"npx create-nx-workspace@latest --preset angular appName" yaz.Böylece aynı CLI ile workspace oluşturmuşuz gibi Nx workspacei oluşturduk.Çalışırken soracak adımlara yes de.Eğer projede hala eksik varsa VSCode'dan çıkış yapıp tekrar gir."npm install" yaz ve eksikler yüklenecek.Tekrar çıkıp gir.Eğer yine olmazsa 
CTRL+SHİFT+P ile extension paneli açıp, "restart ESlink" veya "restart TS server" çek.
3-"e2e"yi test etmek için terminale "npx ng e2e e2eName --watch" yaz.Böylece google test ortamında launchlanacak.Eğer "cypress verification" hatası alırsan, "ng_modules/cypress/lib/tasts" gir ve "verify.js" bul.Burada "VERIFY_TEST_RUNNER_TIMEOUT_MS" değişkeninin değeri default olarak 30000dir.Bunu 100000 yap.
4-Workspacee angular yüklemek için "npm install -D @nrwl/angular" yaz.
5-Artık run yaparken "npx nx serve appName" şeklinde aplikasyonun adını yazarak run ederiz.Böylece Nx ekstra featurelerini aktif ederiz.
6-"libs" içerisine eklemek için "npx ng g lib libName" ekleriz.Mesela "npx ng g lib header"
7-"header" libin içerisine component eklemek içinse "npx ng g component header --project=header" yaz."--project=header" yazarak hangi lib içerisindeki module ait bir component oluşturacağımızı belirtiriz.Böylece "header" componenti oluşturduk.
8-Componentlere storybook eklememiz için önce "npm install -D @nrwl/storybook" yazarak storybook schematics yükleriz.
9-Artık "header" componenti için storybook generate edebiliriz."npx ng g storybook-configuration header" yaz.Çıkan steplere hep "yes" de.Böylece component için storybook oluşturduk.
10-"header" componentinin storybookunu generate içinse "npx ng run header:storybook" yaz.
11-Nx coluda projeyi eklemek için "npx ng add @nrwl/nx-cloud" yaz.Ardından "git add ." yaz.
"git commit -m 'First Commit'" yaz."git push" yaz.
-------------------------------------------------------------------------------------------------------------
*****Bir "json" dosyasını import edebilmek için:
1-"tsconfig.json" gir ve "compilerOptions" objecti içerisine şu ayarları ekle:
"'resolveJsonModule': true,
'esModuleInterop': true,
'allowSyntheticDefaultImports': true"
-------------------------------------------------------------------------------------------------------------
*****FELAKET SENARYOLARI:
1-"npm install".
2-"npm update".
3-"npm cache clean --force" + "npm cache verify".
4-"npm install --legacy-peer-deps" + "npm config set legacy-peer-deps true".
5-"npm install rxjs-compat"
-------------------------------------------------------------------------------------------------------------
*****Typescript için "setTimeout" kullanımı:
1-Mesela önce bir html butonuna bir event atayalım:
"<button (click)='function1()'></button>"
2-Ardından componente gel ve fonksiyonu çağırdıktan sonra içerisine şunu ekle:
"function1(){
  setTimeout(()=>{
    alert('heyy');
  },5000);
}"
3-İçerisinde istediğimiz işlemi yaparız ve delayı da callback olarak sonuna ekleriz.
-------------------------------------------------------------------------------------------------------------
**Sticky Navbar için:
1-Öncelikle eklenecek olan classları oluşturmak için "css" içerisine git.Şu iki classı ekle:
".fixed{
  position: fixed;
  width: 100%;
  transition: all 1.2s ease-in-out;
  top: 0;
  left:0;
}
.nofixed{
  position: static;
  transition:all 1.2s ease-in-out;
  top: -50px;
}".
2-Ardından html gel ve "nav" tagına şu attributeleri ekle: 
"(scroll)='onscroll()' [ngClass]='navbarfixed?'fixed':'nofixed''".
3-Componente gel ve şunları ekle:
"navbarfixed:boolean = false;
@HostListener('window:scroll',['$event']) onscroll(){
  if(window.scrollY>60){
    this.navbarfixed=true;
  }
  else{
    this.navbarfixed=false;
  }
}".
------------------------------------------------------------------------------------------------------------
*****Smooth scroll to top için:
1-Bir html butonuna "function1()" atadık diyelim.Componente şunu yaz:
"function1(){
  window.scrollTo({top: 0, behavior: 'smooth'});
}"
--------------------------------------------------------------------------------------------------------------
*****Klavyeden basılan tuşları dinlemek:
1-Mesela "ESC" tuşu için ascii numarasıyla beraber:
"ESCAPE_KEYCODE = 27;
@HostListener('document:keydown',['$event']) onEscHandler(event: KeyboardEvent){    
  if(event.which === this.ESCAPE_KEYCODE && this.modal==true){
    this.modal=false;}
  if(event.which === this.ESCAPE_KEYCODE && this.failToast==true){
    this.failToast=false;}
  if(event.which === this.ESCAPE_KEYCODE && this.successToast==true){
    this.successToast=false;
  }}".
-------------------------------------------------------------------------------------------------------------
*****Arraydeki duplicate[veya daha fazla tekrar eden] itemleri filtreleme:
1-"array.filter(function (value, index, array) {
  return array.indexOf(value) === index;
})".
-------------------------------------------------------------------------------------------------------------
*****Apiden çekilen objectin propertilerini rxjs ile filtreleme:
1-Apiden "httpclient" ile çağırırken şöyle subscribe ol:
"getAvatars() {
  this.http.get<[]>(
    'https://last-airbender-api.herokuapp.com/api/v1/characters/avatar'
  ).pipe(map( x => x.filter( y => y['name'] == 'Aang') )).subscribe(x=>{
    console.log(x);
    this.object1 = x;
  })}"
2-Böylece sadece adı "Aang" olan objectleri çektik.Artık html içerisinde "object1"i yazdırırsak, tek bir object alacaktır.
-------------------------------------------------------------------------------------------------------------
*****Apiden çekilen nested objectin sadece belirli spesifik propertilerini çekmek[1.Yol]:
1-Objectimiz şudur:
"'date_periods':[
  {
    'id':1,
    'name':'bugün',
    'films':[
      {
        'id':1,
        'name':'Star Wars'
      },
      {...},
      {...}
    ]
  },
  {...},
  {...}
]".
2-Apiden "httpclient" ile şöyle bütün objecti çekeriz:
"get_all_data():Observable<any[]> {
  return this.http
    .get<any[]>('http://localhost:3000/date_periods');}".
3-Şimdi componente servicei inject et ve içerisine gelerek şöyle yaz:
"ngOnInit():void{
  this.dateService.get_all_data().subscribe((response:any)=>{
    response.map((value:any)=>{
      value['films'].map((x:any)=>{
        console.log(x['name'])
      })
    })
  })}".
4-Böylece arrayın içerisindeki objectlerin 'films' propertileri altındaki arraylerin bütün 'name' propertlierinin valuelerini yazdırdık.
-------------------------------------------------------------------------------------------------------------
*****Apiden çekilen nested objectin sadece belirli spesifik propertilerini çekmek[2.Yol]:
1-Objectimiz şudur:
"'actors':[
  {
    'id':1,
    'actor_name':'John',
    'film':'Terminator'
  },
  {
    'id':2,
    'actor_name':'Ronny',
    'film':'Matrix'
  },
  {...}
]".
2-Apiden "httpclient" ile şöyle bütün objecti çekeriz:
"get_actors():Observable<any[]> {
  return this.http
    .get<any[]>('http://localhost:3000/actors');}".
2-Şimdi componente servicei inject et ve içerisine gelerek şöyle yaz:
"ngOnInit(): void {
  this.actorService.get_actors().pipe(
    map((response:any[])=>{
      for(let i=0;i<response.length;i++){
        this.actor_films.push(response[i]['film'])
      }
    })).subscribe()}
let actor_films:any[]=[]".
3-Böylece arrayın içerisindeki objectlerin bütün "film" propertilerinin valuelerini bir array değişkenine pushladık.
-------------------------------------------------------------------------------------------------------------
*****İframedeki Safe url için DOMSanitizer kullanımı:
1-Önce pipe oluşturacağız.Mesela "safepipe" oluştur ve "appModule" içerisinde "declarations[]" arrayine ekle.
2-Pipe içerisine "constructor" oluştur ve "constructor(private sanitizer: DomSanitizer) {}" şeklinde inject et.
3-Ardından transform methodunu şöyle yap:
"transform(url) {
  return this.sanitizer.bypassSecurityTrustResourceUrl(url);
}".
4-Daha sonra Kullanacağın iframe gel ve pipeı şöyle kullan:
"<iframe [src]='x.src | safepipe'></iframe>"
"<iframe src='{{x.src | safepipe}}'></iframe>"
-------------------------------------------------------------------------------------------------------------
*****"innerHTML" ile databasedeki içerisinde html bulunan verileri, html içerisinde renderlayıp görüntülemek:
1-Mesela "json" dosyamızda şöyle bir "people" object olsun:
"{
  'fullname':'<b>Ali Tatar</b>',
  'website':'<em>www.google.com</em>'
}"
2-Bunu html içerisinde normalde sadece text olarak gösterebilirdik.HTML kısmının renderı için şöyle yap:
"<ul>
<li *ngFor='let person of people'>
<span>{{person.fullname}}</span>                    //rendersız
<span [innerHTML]='person.fullname'></span>         //renderlı
<span [innerHTML]='person.website'></span>          //renderlı
</li>
</ul>".
-------------------------------------------------------------------------------------------------------------
*****@ViewChild kullanımı: 2 tip kullanımı vardır:
****Bu senaryoda child Componentteki bir değişkeni, Parent Componentinin içerisinde kullanacağımız "viewChild" ile parenta aktarıp parent içerisinde kullanacağız:
1-Mesela "AppComponent" içerisinde kullandığımız bir "FooterComponent" olsun.Öncelikle FooterComponent içerisinde bir "string1:string = 'Merhaba!'" tanımlayalım.
2-Şimdi parent olan AppComponente gel ve "@ViewChild(FooterComponent) footerComponent:FooterComponent" şeklinde tanımla.Böylece FooterComponenti parenta import ettik ve "FooterComponent" türündeki bir değişkene atadık.Bu değişken ile footerın her özelliğini çekebileceğiz.
3-"AfterWiewInit" içerisine gel ve footerdaki özelliği şöyle çek
****Bu senaryoda tek componentta çalışacağız.Componentin HTMLinden bir elementi çekip, componentte kullanarak DOM manipülasyonu yapacağız:
1-Mesela HTMLimizde bir "<div #test1>Just Text</div>" elementi oluştur ve componente dön.
2-Burada elementi "@ViewChild('test1') element1!:ElementRef" şeklinde çektik.Buradaki "element1", elementi atadığımız bir variabledır.
3-Ardından "AfterWiewInit" componente implement et ve içerisine gelerek şunu yaz:
"ngAfterViewInit(): void {
  this.element1.nativeElement.innerText='Changed!'
}".
4-Böylece DOM manipüle ettik ve içeriğini değiştirdik.
***"ViewChild" kullanırken, "AfterViewInit" içerisinde kullanmalısınız!!!
------------------------------------------------------------------------------------------------------------
*****@Input kullanımı: Child componentte bulunun bir değeri, parent component içerisinde değiştirilmesini sağlar.
****Eventsiz kullanımı:
1-Öncelikle elimizde bir child olan "FooterComponent" ve parent olan "AppComponent" olsun.Child componente gir ve "@Input() childString1:string='Merhaba!'" tanımla.
2-Childın HTMLine gir ve bu değişkeni şöyle bind et: "<p>{{childString1}}</p>".Artık FooterComponentin viewinde paragraf olarak "Merhaba" yazacaktır.Bunu parentından değiştireceğiz.
3-Parent componente gel ve "parentString1:string='Değişti!'" tanımla.Yeni bir değişken oluşturduk ve value verdik.
4-Parentın htmline gel ve Footer Componenti tanımladığımız kısma şunu ekle:
"<app-footer [childString1]='parentString1'></app-footer>".Böylece artık Footerın viewindaki paragraf, "Değişti!" olarak görünecektir.
------------------------------------------------------------------------------------------------------------
*****@Output kullanımı: Parent componentte bulunun bir değeri, child component içerisinde değiştirilmesini sağlar.
****Eventle beraber kullanımı:
1-Öncelikle elimizde bir child olan "FooterComponent" ve parent olan "AppComponent" olsun.
2-Childın htmline gir ve bir buton tanımlayarak bu butona da click eventini şöyle tanımla: 
"<button (click)='sendData1()'></button>".
3-Child componente gir ve "string1:string='Merhaba!'" tanımla.
4-Ayrıca component içerisinde "@Output() childStringSend1:EventEmitter<string> = new EventEmitter()" ekle.
5-Atadığımız eventi de componentte şöyle tanımla:
"sendData1(){
  this.childStringSend1.emit.(this.string1)
}".
6-Parentın htmline gel ve footerı tanımladığınz alanı şöyle düzenle:
"<app-footer (childStringSend1)='getData1($event)'></app-footer>".
7-Parentın componentine gir ve yeni bir boş string oluştur: "childStringReceived1:string=''".
8-Ardından parentın htmlinde oluşturduğumuz fonksiyonu componentte çağır ve şöyle yaz:
"getData1(event:any){
  this.childDataReceived1=event;
}".
9-Böylece parenttaki değişkene, childdaki stringin değerini atadık ve parentın htmlinde istediğimiz yerde kullanabiliriz.Childdaki clicker ile çalışacaktır.
****Eventsiz kullanımı:
1-Öncelikle elimizde bir child olan "FooterComponent" ve parent olan "AppComponent" olsun.
2-Child componente gir ve "string1:string='Merhaba!'" tanımla.
3-Ayrıca component içerisinde "@Output() childStringSend1:EventEmitter<string> = new EventEmitter()" ekle.
4-Parentın htmline gel ve footerı tanımladığınz alanı şöyle düzenle:
"<app-footer (childStringSend1)='getData1($event)'></app-footer>".
5-Parentın componentine gir ve yeni bir boş string oluştur: "childStringReceived1:string=''".
6-Ardından parentın htmlinde oluşturduğumuz fonksiyonu componentte çağır ve şöyle yaz:
"getData1(event:any){
  this.childDataReceived1=event;
}".
7-Böylece parenttaki değişkene, childdaki stringin değerini atadık ve parentın htmlinde istediğimiz yerde kullanabiliriz.
------------------------------------------------------------------------------------------------------------
*****Componentler[sibling] arasında data ve değişken paylaşımı.2 yöntemi vardır:
****Bu senaryoda bir componentte input ile girilen valueyi her tıklayışta, başka componentte anlık olarak görüntüleyeceğiz:
1-Parentları[AppComponent] aracılığıyla 2 child component[sibling] arasında data paylaşılabilir.Önce service yazıcaz.
2-Cmd'ye "ng g s data" yazarak data service oluştur."private messageSource = new BehaviorSubject<string>('')" değişkeni oluşturarak "messageSource" değişkenine boş bir "default" message tanımlarız.
3-Mevcut mesajı da anlık çekebilmek için "currentMessage = this.messageSource.asObservable()" değişkenine atarız.
4-Sonrasında ise, "input search" ile girdiğimiz değeri değiştirebilmek için fonksiyon tanımlarız:
"changeMessage(message:string){
  this.messageSource.next(message);
}"
5-Şimdi input girilecek componente gel ve data servicei import et.
6-Forma ait olan inputun valuesini, değişkene şöyle ata: "filterText1:string = this.form1.get('filterText1')?.value".Yani form1 içerisinde "filterText1" olarak tanımlanmış kontrolün valuesini, bu değişkene atadık.
7-Ardından input içerisine "<input [(ngModel)]='filterText1'>" şeklinde bind ederiz çünkü biz input girdikçe, değişken de değişecek.
8-İnputa "<input (keyup)='change()'>" fonksiyonu ata.Componente gelip fonksiyonu çağır ve servicete yazdığımız fonksiyonla şöyle ilişkilendir:
"change(){
  this.dataService.changeMessage(this.filterText1);
}".
9-Böylece yazdığımız valueyi servicee ilettik ve fonksiyon, default mesajı değiştirdi.Ardından "ngOnInit" içerisine de 
"ngOnInit(): void {
  this.dataService.currentMessage.subscribe(data=>{
    this.filterText1=data;
  })
}" ekle.
10-Şimdi parent componente gel.Service import et ve "filterText1!:string" buraya da tanımla.Ve bunda da "ngOnInit" içerisine
"ngOnInit(): void {
  this.dataService.currentMessage.subscribe(data=>{
    this.filterText1=data;
  })
}" ekle.
11-Şimdi sibling componente gel.Service import et."filterText1!:string;" buraya da tanımla.Ve bunda da "ngOnInit" içerisine
"ngOnInit(): void {
  this.dataService.currentMessage.subscribe(data=>{
    this.filterText1=data;
  })
}" ekle.
12-Ve bu componentin hmmtlinde bir yerde "{{filterText1}}" bind et.Artık ilk componentin inputuna herhangi bir value girdiğimizde, bu componentteki değişkenin valuesini de değiştirmiş olacağız.
13-Artık buradaki ürünleri filtrelemek çok basit.Filtre için oluşturduğumuz "filtre" pipeını, 
"*ngFor='let city of cities | filter:filterText'" olarak ekle.
****Bu senaryoda bir componentte input ile girilen valueyi her tıklayışta, başka componentte anlık olarak görüntüleyeceğiz:
1-Mesela elimizde "Sibling1" ve "Sibling2" isimli 2 adet component olsun.Önce service transport için "dataTransfer" adında servis oluştur.İçerisine gir.
2-Decoratorün içerisine boşalt çünkü local kullanacağız.Ardından içerisine şunları yaz:
"subject1 = new BehaviorSubject<any>('');
emit<T>(data:T){
  this.subject1.next(data);
}
on<T>():Observable<T>{
  return this.subject1.asObservable();
}".
3-İnput yazacağımız Sibling1 componentin htmline gel ve "dataTransfer" servisi lokal olarak inject et.
4-Ardından htmline gir ve şunu ekle: 
"<input (keyup)='send1($event)' formControlName='input1' type='text'>".
5-Bu input için reactive control oluşturacağız.Önce "appModule" içerisine "ReactiveFormsModule" import et.
6-Ardından Sibling1 componentine gel ve şunları ekle:
"string1:string="";
input1 = this.fb.control(this.string1,Validators.required);
send1(event:any){
  this.dataTransferService.emit<string>(event.target.value);
}".
7-Artık her inputta, aldılayacak ve servise gönderecektir.Şimdi Sibling2 componentine gel."dataTransfer" servisi lokal olarka inject et.
8-Ardından içerisine şunları gir:
"data1:string = "";
ngOnInit(): void {
  this.dataTransferService.on<string>().subscribe(data=>{
    this.data1=data;
  })
}".
9-Böylece her data değiştiğinde subscribe olarak "data1" değişkenine aktaracağız.Şimdi ise Sibling2 htmli içerisine gir ve değişkeni görüntülemek için şöyle ekle: "<p>{{data1}}</p>"
------------------------------------------------------------------------------------------------------------
*****Custom filter pipe ile sibling componentler arasında arama[search] motoru yapmak:
****Bu senaryoda Elimizde "NavComponent" ve "MainComponent" var.Kullanıcı, Nav componentindeki inputa değer girdiğinde, Main componentindeki ürünleri filtreleyecek:
1-Terminal ile, pipeı eklemek istediğin componentin dizinine gel.Terminalden "productFilter" pipeını oluştur.
2-Burada transform metoduyla, "filterText2" olarak htmldeki inputa alacağımız değerlere belirli işlemler uygulatacağız.Tabi burada "Product" objectini, buraya import etmemiz gerekecek çünkü metodun içerisinde kullanıyoruz.Mesela:
"transform(value: Product[], filterText2?: any): Product[] {
    filterText2 = filterText2?filterText2.toLocaleLowerCase('tr'):null;
    return filterText2?value.filter((p:Product)=>p.name.toLocaleLowerCase('tr').indexOf(filterText2)!==-1):value;
}"
3-Ardından "dataTransfer" adında bir service oluştur ve içerisine şunları gir:
"subject1 = new BehaviorSubject<any>('');
emit<T>(data:T){
  this.subject1.next(data);
}
on<T>():Observable<T>{
  return this.subject1.asObservable();
}".
4-Servisin decoratorını boşalt çünkü local olarak kullanacağız.
4-İnput girilecek olan "Nav" componentinin htmline gel ve şunu yaz:
"<input (keyup)='send1($event)' formControlName='input1' type='text'>"
5-Bu input için reactive control oluşturacağız.Önce "appModule" içerisine "ReactiveFormsModule" import et.
6-Nav componentine gel ve "dataTransfer" servisini lokal olarak inject et.Ardından içerisine şunları ekle:
"string1:string="";
input1 = this.fb.control(this.string1,Validators.required);
send1(event:any){
  this.dataTransferService.emit<string>(event.target.value);
}".
7-Artık her inputta, algılayacak ve servise gönderecektir.Şimdi Main componentine gel."dataTransfer" servisi lokal olarka inject et.
8-Ardından içerisine şunları gir:
"data1:string = "";
ngOnInit(): void {
  this.dataTransferService.on<string>().subscribe(data=>{
    this.data1=data;
  })
}".
9-Böylece her data değiştiğinde subscribe olarak "data1" değişkenine aktaracağız.Şimdi ise Sibling2 htmli içerisine gir ve burada "ngFor" ile belirttiğin ürünleri, 
"<div *ngFor='let product of products | productFilter:data1'>" şeklinde yap.Yani sadece pipe kısmını ekle.
Burada "productFilter", üreteceğimiz custom pipeın ismidir."data1" ise, componentte atadığımız değişkendir.
-------------------------------------------------------------------------------------------------------------
*****Pipes:
1-Birden fazla pipe türü vardır.İlk olarak 'date' pipeları inceleyelim:
****Date Pipe OPTİONS[Parametreleri ayarlanmış olan templatelerdir]:
-'short' = Mesela: "{{date1 | date :'short'}}"
-'medium'
-'long'
-'full'
-'shortDate'
-'mediumDate'
-'longDate'
-'fullDate'
-'shortTime'
-'mediumTime'
-'longTime'
-'fullTime'
****Date Pipe PARAMETERS: Aşağıdaki parametreleri birden fazla tekrar[max 5 tekrar], konumlarını değiştirerek, vs dilediğimiz şekilde formatlayarak kullanabiliriz:
-y[year] : Yıl.Mesela: "{{date1 | date :'y/MM/d hh:mm:ss:SS'}}".
-Y[Week-numbered year] : Yıl.
-M[month] : Ay[1-12]|[January,February..December].
-L[month-standalone] : Ay[1-12]|[January,February..December].
-W[weekOfMonth] : Aydaki hafta[1-5].
-w[weekOfYear] : Yıldaki hafta[1-53].
-d[day] : Gün[1-31].
-E[enumericDay] : Gün[Sunday,Monday..Saturday]
-h[hour] : Saat.[0-23]
-h[hour] : Saat[1-12].
-m[minute] : Dakika[0-59].
-s[second] : Saniye[0-59].
-S[millisecond] : Milisaniye[0-999].
-a[period] : Gün dönümleri.[PM,AM,a,p,mid]
-B[period] : Gün dönümleri.[am,pm,midnight,noon,morning,afternoon,evening,night..]
-b[period] : Gün dönümleri.[am,pm,midnight,noon,morning,afternoon,evening,night..]
-z[zone] : Zaman dilimi[GMT-8,GMT-08:00..].
-Z[zone] : Zaman dilimi[-0800,GMT-8:00,-08:00..].
-O[zone] : Zaman dilimi[GMT-8,GMT-08:00..].
2-"uppercase" pipe: Büyük harfe dönüştürür.Mesela: "{{string1 | uppercase}}".
3-"lowercase" pipe: Küyük harfe dönüştürür.Mesela: "{{string1 | lowercase}}".
4-"titlecase" pipe: Sadace baş harfleri dönüştürür.Mesela: "{{string1 | titlecase}}".
3-"currency" pipe: Sayısal verilere, para birimi ekler.
****Currency Pipe OPTİONS: Bazı optionlar, bazı parametreler alabilir:
--currencyCode : Ülkenin para birimlerinin kodlarıdır."İSO 4217"de tüm ülke para birimleri mevcuttur.
--display : Para birimlerinin formatlarıdır.Bunlar:
-code : Kodu beraberinde gösterir.Mesela: "{{number1 | currency: 'USD' : 'code'}}".
-symbol : Parayı sembolüyle beraber gösterir.Mesela: "{{number1 | currency: 'USD' : 'symbol' : '4.2-2'}}".
-symbol-narrow : Para birimi olarak birden fazla sembolü bulunan yerel ayarlar için kullanılır.Mesela doların simgesi "$".Fakat Kanada Dolarının[CAD] simgesi ise "CA$" şeklindedir.
-string : Para birimi olarak gösterilecek string değerdir.Herhangi birşey girebiliriz.HTML entity ile de seçebiliriz.Mesela "Türk Lirası" için: "{{number1 | currency: 'TRY' : '&#8378;' : '4.2-2'}}".
--Digitsİnfo : 3 farklı birimden oluşur.Mesela : "4.2-3".İnteger kısmı minimum 4, decimal kısmı minimum 2 ve maksimum 3 olacağını söyler.Eğer sayı, minimum değerlerden küçükse; display edilirken sol tarafına otomatik olarak sıfır[0] eklenir.
4-"decimal" pipe: Aynı "currency"de kullandığımız gibi sayının decimal ve integer kısmını düzenler.3 birimden oluşur.Mesela : "{{number1 | number: '4.2-3'}}".Eğer sayıyı sadece integer olarak göstereceksek "x.0-0" şeklinde kullan.
5-"percent" pipe: Sayıyı, yüzdelik dilimlere dönüştürür.Genelde 0 ile 1 arasındaki ondalık datalarda kullanılır.Mesela: "{{number1 | percent}}".Ayrıca bunda da sayının decimal ve integer kısmını düzenleyebiliriz.Mesela: "{{number1 | percent : '4.2-3'}}".
6-"JSON" pipe: Bir valueyi JSON formatındaki bir stringe dönüştürür.Genelde nested objectleri debugging içindir.Mesela elimizde bir "object1 = {name:'ali',lastname:'koç',skills:{skillname:'javascript',certificates:[1,2,3,4,5]}}" objecti olsun.Buna html içerisinde "{{object1|json}}" uygularsak, yine aynı şekilde HTMLde de görüntüleriz.
7-"Slice" pipe: Bir arrayın hangi item aralığını slice ederek döndüreceğini belirtiriz.Başlangıç ve bitiş indexlerini belirtiriz.Mesela: "<div *ngFor='let city of cities | slice: 2:16'></div>".
8-"async" pipe: BUNU ANLAMADIM!
------------------------------------------------------------------------------------------------------------
*****Locale Date formatını "tr" olarak ayarlamak için:
1-"app.module" gel ve "import { registerLocaleData } from '@angular/common';import localeTr from '@angular/common/locales/tr';" import et.
2-İçerisinde araya "registerLocaleData(localeTr, 'tr')" ekle.
3-"providers[]" arrayına da şunu ekle: "{provide:LOCALE_ID, useValue:'tr'}".
4-Artık dateler, default olarak tr formatında görüntülenecektir.
------------------------------------------------------------------------------------------------------------
*****Observable object kullanmak için:
1-"OnInit" ve "Observable" modüllerini componente ekleriz.Eğer birden fazla "observer" kullanacaksak, "Subject" modulünü de ekleriz.Subjecte birden fazla "observer" tarafından "subscribe" olunabilir.Sıradan bir "subject" kullanırken "observer"ı, tüm iletilen datalardan önce kullanırsak; sonrasındaki tüm dataları alır.Fakat belirli datalardan sonra "observer" kullanırsak, öncesinde kalan dataları "subscribe" edemeyecektir.Üç farklı "subject" vardır:
1-A = BehaviorSubject : Akışa "subscribe" olan "observer"ın, akıştaki bir önceki datadan başlayarak dataları çekmesini sağlar."İnitial value"si olmak zorundadır."BehaviorSubject" modülü eklenmelidir.Mesela:
"const subject1 = new Subject('Hilmi1');
subject1.subscribe(data=>console.log('Observer1' + data));
subject1.subscribe(data=>console.log('Observer2' + data));
subject1.next('ali2');
subject1.next('veli3');
subject1.subscribe(data=>console.log('Observer3' + data));
subject1.next('halil4');
//Output:
Observer1 Hilmi1
Observer2 Hilmi1
Observer1 ali2
Observer2 ali2
Observer1 veli3
Observer2 veli3
Observer3 veli3
Observer1 halil4
Observer2 halil4
Observer3 halil4"
1-B = ReplaySubject : Akışa "subscribe" olan "observer"ın, akıştaki "n" kadar önceki datadan başlayarak dataları çekmesini sağlar."ReplaySubject" Modülü eklenmelidir.Mesela:
"const subject1 = new ReplaySubject(2);
subject1.subscribe(data=>console.log('Observer1' + data));
subject1.subscribe(data=>console.log('Observer2' + data));
subject1.next('ali2');
subject1.next('veli3');
subject1.subscribe(data=>console.log('Observer3' + data));
subject1.next('halil4');
//Output:
Observer1 ali2
Observer2 ali2
Observer3 ali2
Observer1 veli3
Observer2 veli3
Observer3 veli3
Observer1 halil4
Observer2 halil4
Observer3 halil4"
2-C = AsyncSubject : Akışa "subscribe" olan "observer"ın, akıştaki sadece son datayı çekmesini sağlar.Sonuncu veriyi anlayabilmesi için, "complete()" metodu zorunludur."AsyncSubject" modülü eklenmelidir.Mesela:
"const subject1 = new AsyncSubject();
subject1.subscribe(data=>console.log('Observer1' + data));
subject1.subscribe(data=>console.log('Observer2' + data));
subject1.next('ali2');
subject1.next('veli3');
subject1.subscribe(data=>console.log('Observer3' + data));
subject1.next('halil4');
subject1.complete();
//Output:
Observer1 halil4
Observer2 halil4
Observer3 halil4"
***Observable objectlerine typeları "<string>","<number>" vs şeklinde veririz.
***"next()" metodunu "Obversable" objectine data iletmek için, her evrede sınırsız şekilde kullanabiliriz.Ayrıca "observer"a, iletilen verileri sunar.Observer yani subscribe olunduğu zaman ise bu dataları okur.
***Veri akışının sonlandığını belirtmek için "complete()" metodunu kullanırız.Ayrıca "observer"a, bu fonksiyondan sonra iletilen herhangi datayı kabul etmemesi gerektiğini bildirir.
***Atanan değişkeni çağırıp subscribe[akışı izlememizi sağlar] ediyoruz.Akıştan veri elde eden, subscribe ederek veriyi izleyen ve isteyen; tüketici olan yapıya "observer" diyoruz.
9-Scheduler : Bu object, "subscribe"ın ne zaman başlayacağını ve datanın ne zaman "observer"lara iletileceğini kontrol eder.Kısacası zamanlayıcıdır.Üç bileşenden oluşur:
9-A = Executeion Context : Taskın nerede ve ne zaman çalıştırılacağını gösterir.
9-B = Execution Policy : Belirli politikala göre taskların nasıl saklanacağı ve hangi sırayla alınacağı belirtir.
9-C = Clock : "now()" metodu sayesinde sanal olarak, mevcut zamanın bilgisinin alınmasını sağlar."Observer"lar, bu zamansal bilgiye uyarak çalışırlar.
10-4 adet Scheduler türü vardır:
10-A-queueScheduler : Yapılacak işi kuyruğa[queue] alır.Belli bir sıra ile arka arkaya çalıştırılacak işler için kullanılır."QueueScheduler" modülünü ekleriz.
10-B-asapScheduler : Micro tasklar için kullanılır.Mevcut işten sonra ve bir sonraki işten önce çalışır.Asenkron dönüşümler için kullanılır."AsapScheduler" modülünü ekleriz.
10-C-asyncScheduler : Zaman tabanlı işlemlerde kullanılır."setTimeOut()" metodu ile çalışır ve bu yüzden de datalar, "observer"a asenkron halde iletilir.Kısaca zamanlayıcıdır."AsyncScheduler" modülünü ekleriz.
10-D-animationFrameScheduler : Browserın, bir sonraki içeriği yeniden boyamadan önce triggerlanan bir türdür."AnimationFrameScheduler" modülünü ekleriz.
11-RxJS kütüphanesindeki "creation" operatörler:[amaçları observation objectleri oluşturmak ve döndürmektir]
11-A-ajax() = Herhangi bir endpointe[JSONUrl,vs..] yapılan bir request sonucunda gelen sonuçları "Observable" olarak döndürür."ajax" modülünü çağırırız.Fakat bunun yerine endpointdeki dataları leech için "HttpClient" librarysini kullanın.
11-B-bindCallback = Özünde operatör değildir.Yapılan işlemlerin ardından callback fonksiyonları sağlar ve bu callback fonksiyonunu, "Observable" objecti olarak döndürür."bindCallback" modülünü çağırırız.
11-C-defer = Kısaca "Observable" objectini, bir "observer" tarafından subscribe olunana kadar oluşturmaz, başlatmaz; bekletir.Bunu her "subscribe" için yapar."defer" modülü ekleriz.Mesela:
"const obsv1 = of(new Date().getMinutes());
const obsv2 = defer(()=>of(new Date().getMinutes()));
timer(5000).subscribe(()=>{
  obsv1.subscribe(data=>console.log('Observable1 dakikası:' + data));
  obsv2.subscribe(data=>console.log('Observable2 dakikası:' + data));
});
//Output:
Observable1 dakikası:10
Observable2 dakikası:15"
11-D-empty = Boş bir "Observable" objecti döndürür.Yani observableın streaminde herhangi bir data bulunmaz."empty" modülünü ekleriz.
11-E-from = Herhangi bir arrayi veya mesela "[1,2,3]", "[{},{},{}]" veya "[[],[],[]]" gibi koleksiyonel objectleri alır ve her bir itemını "Observable" objecti olarak döndürür."from" modülü ekleriz.Mesela:
"const araclar1=new Map<string,number>();
araclar1.set('Klavye','1');
araclar1.set('Mouse','2');
araclar1.set('Kitap','3');
const obsv1 = from(araclar).subscribe(data=>console.log(data));
//Output:
['Klavye',1]
['Mouse',2]
['Kitap',3]"
11-F-fromEvent = Herhangi bir HTML objectinin belirtilen eventine bağlanarak, bu eventi "Observable" objecti olarak sunar."fromEvent" modülü ekleriz.Mesela htmlimizde "<button>tık1</button>" elementimiz olsun:
"const button1 = document.getElementsByTagName('button')[0];
const obsv1 = fromEvent(button1, 'click').subscribe(data=>{
  console.log(data);
})
//Output:
click{Object...}
"
11-G-generate = Verilen koşula göre loop oluşturarak "Observable" objecti olarak döndürür.Syntaxı, "for" loopuna çok benzer.Output için "repeat()" metodu sayesinde string de kullanılabilir."generate" modülü ekleriz.Mesela:
"const obsv1 = generate(100 , x=>x>0 , x=x-3).subscribe(data=>console.log(data));
//Output:
100
97
94
...
1"
11-H-interval = Belirtilen number valuesine[millisecond] karşılık gelen zaman aralığında periodlar oluşturur."interval" modülünü ekleriz."subscribe" kullanılan metodun "data" parametresi, bize her periodun indexini döndürecektir.Mesela:
"const obsv1 = interval(5000).subscribe(data=>console.log('merhaba'));
//Output:
Her 5 saniyede bir 'merhaba' yazacak"
11-I-of = Verilen herhangi tür valueleri birer "Observable" objectine dönüştürür."of" modülünü ekleriz.Mesela:
"const obsv1 = of(1,5,'Ahmet',[true,false]).subscribe(data=>console.log(data));
//Output:
1
5
Ahmet
[true,false]"
***"from" ile "of" operatörleri arasındaki fark şudur: "from", sadece koleksiyonel ve arraysel değerleri; "of" ise herhangi verilen değeri Observable objectine dönüştürür.
11-J-range = Belirtilen bir aralıkta, arraysel value halinde yayılan bir "Observable" objecti döndürür."range" modülü ekleriz.Mesela:
"const obsv1 = range(555,50).subscribe(data=>console.log(data));
//Output:
555
556
557
...
604"
11-K-throwError = Üzerinde hiçbir item barındırmayan ve bir "error" throw eden bir "Observable" objecti döndürür."throwError" modülünü ekleriz.Mesela:
"throwError(new Error('Örnek bir Hata!')).subscribe(data=>console.log(data));
//Output:
Örnek bir Hata!"
11-L-timer = Belirtilen süre kadar[millisecond] bekledikten sonra mevcut "stream"i yayacak olan bir "Observable" objecti döndürür.Kısaca delay işlevi görür."timer" modülünü ekleriz.İkinci parametresi bir "scheduler"dir.Yani zamanlayıcıdır ayni "interval" operatörü işlevi görür.Mesela:
"const obsv1 = timer(3000, 2000).subscribe(()=>console.log('merhaba!'));
//Output:
3 saniyenin ardından 'merhaba!'
Her 2 saniyede bir 'merhaba!'"
11-M-iif = İki "Observable" objecti arasında belirtilen şarta bağlı olarak seçim yapar.Yani "if" koşulu gibidir.İlk parametresi koşulu belirtir.İkinci parametresi koşulun "true" olması; üçüncü parametresi de "false" olması durumunda çalışacak bloklardır."iif" modülünü ekleriz.Mesela:
"let state1:boolean = true;
const obsv1 = iif(()=>state1, of(3,5,7), of(10,11,12));
obsv1.subscribe(data=>console.log(data));
//Output:
3
5
7"
12-RxJS kütüphanesindeki "join creation" operatörleri:[birden fazla observable objectleri içindir]
12-A-combineLatest = Belirtilen tüm "Observation" objectlerinin streamlerindeki en sonuncu valueleri yakalar ve bu valuelerle bir "Kombinasyon" yaratır.Kombinlenecek olan "Obversable" objectlerin, operatörün içerisindeki dizilişlerine dikkat et!"combineLatest" modülü ekleriz.Mesela:
"const obsv1 = of('a','b','c');
const obsv2 = of(1,2,3);
const obsv3 = of(7,8,9);
combineLatest(obsv1,obsv2,obsv3).subscribe(data=>console.log(data));
//Output:
[c,3,7]
[c,3,8]
[c,3,9]"
12-B-concat = Belirtilen tüm "Observable" objectlerini sıralı bir şekilde yayar ve bunları tek bir "Observable" objecti olarak döndürür."concat" modülünü ekleriz.Mesela:
"const obsv1 = of(1,2);
const obsv1 = of(4,5);
const obsv1 = of('a');
concat(obsv1,obsv2,obsv3).subscribe(data=>console.log(data));
//Output:
1
2
4
5
a"
***"concat" ile "merge" operatörü arasındaki fark şudur: "concat", aldığı objectlerin valuelerini birleştirerek, sıralı bir şekilde teker teker görüntüler."merge" ise, bunların zamansal farklılıklarını da baz alarak işlem yapar.
12-C-forkJoin = Kendisine verilen birden fazla "Observable" objectinin tamamlanmalarını bekler ve ardından da her bir objectin yayınlanan en sonuncu değerleri çekerek, tek bir sonuç olarak döndürür."forkJoin" modülü ekleriz.Mesela:
"const obsv1 = of('a','b','c');
const obsv2 = of(1,2,3);
const obsv3 = of(7,8,9);
forkJoin(obsv1,obsv2,obsv3).subscribe(data=>console.log(data));
//Output:
[c,3,9]"
12-D-merge = Belirtilen tüm "Observable" objectlerini birleştirerek, tek bir "Observable" objecti haline getirir ve döndürür.İşlem yaptığı "Observable" objectleri arasında zamansal farklılıklar olmalıdır."merge" modülü ekleriz.
12-E-partition = Seçilen "Observable" objectini belirtilen koşula göre, bu koşula uyanlar ve uymayanlar olmak 
üzere objectin itemlerini ikiye bölerek ayırır.Sonuçlanan bu iki ayrı grubu, array içerisinde[obs1,obs2] 2 adet item halinde döndürür. "partition" modülünü ekleriz.Mesela:
"const obsv1 = of(1,2,3,6,7,9);
const [obsv2,obsv3] = partition(obsv1, x=>x % 3 == 0);
obsv2.subscribe(data=>console.log('uyanlar ' + data));
obsv3.subscribe(data=>console.log('uymayanlar ' + data));
//Output:
uyanlar 3
uyanlar 6
uyanlar 9
uymayanlar 1
uymayanlar 2
uymayanlar 7"
12-F-race = Birden fazla "Observable" objectinin bulunduğunu varysayarsak; bunların arasında ilk streame başlayacak olan objecte "subscribe" olur."race" modülü ekleriz.Mesela:
"const obsv1 = interval(1000).pipe(mapTo('Birinci'));
const obsv2 = interval(250).pipe(mapTo('İkinci'));
const obsv3 = interval(2000).pipe(mapTo('Üçüncü'));
race(obsv1,obsv2,obsv3).subscribe(data=>console.log(data));
//Output:
İkinci
İkinci
..."
12-G-zip = Birden fazla "Observable" objectlerinden, streamdeki aynı perioddaki dataları toplar ve arrayler olarak döndürür."zip" modülü ekleriz.Mesela:
"const obsv1 = of(1,2,3);
const obsv2 = of(4,5,6);
const obsv2 = of(7,8,9);
zip(obsv1,obsv2,obsv3).subscribe(data=>console.log(data));
//Output:
[1,4,7]
[2,5,8]
[3,6,9]"
12-H-pipe = Kod içerisinde yaygın olarak kullanılan birden fazla operatör dizisi varsa eğer, bu fonksiyon kullanılabilir.Kısaca "Observable" objectine birden fazla operatörle müdahale edeceksek, hepsini ayrı ayrı yazmaktansa; "pipe" metoduyla tekte müdahale edebiliriz."pipe" modülü ekleriz.Mesela:
"const obsv1 = of(1,4,7,234,34,3,99);
obsv1.pipe(filter(x=> x%3 == 0),map(x=>x + 'degerim')).subscribe(data=>console.log(data));
//Output:
234 degerim
3 degerim
99 degerim"
13-RxJS kütüphanesindeki "filtering" operatörleri:
13-A-audit = Bir süre için "Observable" streamindeki valueler üzerinde işlem yapmamıza izin verir ve ardından da en sonuncu değerleri yayınlar.Yani streamde gelen dataların arasına "audit" ile gireriz ve zamansal olarak durdururuz.İşte bu duran zamandaki akan değerlerin en sonuncusunu seçer ve döndürür.İçerisinde genellikle "interval" ile kullanılır."audit" modülü ekleriz.Mesela:
"const obsv1 = interval(1000);
obsv1.pipe(audit(x=>interval(2000)),map(x=>x + 'degerim')).subscribe(data=>console.log(data));
//Output:
2. saniyede: 2 degerim
5. saniyede: 5 degerim
8. saniyede: 8 degerim
11. saniyede: 11 degerim
..."
13-B-auditTime = "audit" operatörünün parametreli[millisecond] halidir.Bunu tercih et."auditTime" modülü ekleriz.Mesela:
"const obsv1 = interval(1000);
obsv1.pipe(auditTime(2000),map(x=>x + 'degerim')).subscribe(data=>console.log(data));
//Output:
2. saniyede: 2 degerim
5. saniyede: 5 degerim
8. saniyede: 8 degerim
11. saniyede: 11 degerim
..."
13-C-debounce = Streamdeki valuelerin zaman aşımı sürelerini belirleyebilmek için kullanılır.Kısaca streamin zamanını kontrol ederek; belirtilen zamanın altındaki valueleri görmezden gelir.Böylece mesela bir tıklama eventine 1 saniye kısıtlaması getirerek, 1 saniyede sadece bir kez gerçekleşmesini sağlayarak; bu koşulu karşılayan valueleri, zaman aşımı bittikten sonra döndürürüz."debounce" modülü ekleriz.Mesela:
"const obsv1 = fromEvent(document,'click').pipe(debounce(x=>interval(1000))).subscribe(()=>console.log('tıklandı'));
//Output:
Böylece her 1 saniyede sadece bir kez eventi okuyacak ve bir kez 'tıklandı' yazacak"
13-D-debounceTime = "debounce" operatörünün parametreli[millisecond] halidir.Bunu tercih et."debounceTime" modülü ekleriz.Mesela:
"const obsv1 = fromEvent(document,'click').pipe(debounceTime(1000)).subscribe(()=>console.log('tıklandı'));
//Output:
Böylece her 1 saniyede sadece bir kez eventi okuyacak ve bir kez 'tıklandı' yazacak"
13-E-distinct = Streamdeki veriler içerisindeki tekrar eden verileri, tekil olarak döndürür."distinct" modülü ekleriz.Mesela:
"const obsv1 = of(1,3,5,5,6,6);
obsv1.pipe(distinct(x=>x)).subscribe(data=>console.log(data));
//Output:
1
3
4
6"
13-F-distinctUntilChanged = Streamdeki verileri değişiklik olana kadar tekilleştirir.Yani "distinct" gibi genel bazlı gözlem yapmaz.İndex olarak 0dan başlar ve sıralı halde valueleri gözlemler.Genellikle istatistiksel çalışmalarda kullanılır."distinctUntilChanged" modülü ekleriz.Mesela:
"const obsv1 = of<Person>(
  {age:10,name:'ali'}
  {age:15,name:'ali'}
  {age:30,name:'veli'}
  {age:30,name:'murat'}
  {age:35,name:'murat'}
  );
  obsv1.pipe(distinctUntilChanged((p:Person, q:Person) => p.name == q.name)).subscribe(data=>console.log(data));
//Output:
{age:10 , name:ali}
{age:30 , name:veli}
{age:30 , name:murat}"
13-G-distincUntilKeyChanged = "distinctUntilChanged" operatöründen tek farkı, parametre olarak "key" kullanmasıdır.Yani objectler üzerinde çalışır.Objectlerde bunu tercih et."distinctUntilKeyChanged" modülü ekleriz.Mesela:
"const obsv1 = of<Person>(
  {age:10,name:'ali'}
  {age:15,name:'ali'}
  {age:30,name:'veli'}
  {age:30,name:'murat'}
  {age:35,name:'murat'}
  );
  obsv1.pipe(distinctUntilKeyChanged('name').subscribe(data=>console.log(data));
//Output:
{age:10 , name:ali}
{age:30 , name:veli}
{age:30 , name:murat}"
13-H-elementAt = Streamdeki itemler içerisinden index numarası verilen değeri döndüren operatördür."elementAt" modülü ekleriz.Mesela:
"const obsv1 = of(1,2,3,4,5,6,7,8,9).pipe(elementAt(5)).subscribe(data=>console.log(data));
//Output:
6"
13-I-filter = Belirtilen "Observable" objectindeki dataları, belirli bir şarta göre yayınlar.Kısaca filtreleme yapar."filter" modülü ekleriz.Mesela:
"const obsv1 = of('ahmet','mehmet','hilmi','ali');
obsv1.pipe(filter(x=>x.indexOf('a') == 1)).subscribe(data=>console.log(data));
//Output:
ahmet
ali"
13-J-first = Streamdeki ilk valueyi döndürür."first" modülü ekleriz.Mesela:
"const obsv1 = of(1,2,3,4,5).pipe(first()).subscribe(data=>console.log(data));
//Output:
1"
13-K-ignoreElements = Belirtilen "Observable" objecti tarafından yayınlanan tüm itemleri yok sayarak görmezden gelir.Yalnızca "complete" ve "error" outputlarını yakalar."ignoreElements" modülü ekleriz.Mesela:
"const obsv1 = of(1,2,3,4).pipe(ignoreElements()).subscribe({
  error : error => console.log(error),
  complete : () => console.log('the end')
});
//Output:
the end"
13-L-last = Streamdeki son valueyi döndürür."last" modülü ekleriz.Mesela:
"const obsv1 = of(1,2,3,4,5).pipe(last()).subscribe(data=>console.log(data));
//Output:
5"
13-M-sample = Periyodik zaman aralıkları içerisinde, bir "Observable" tarafından yayınlanan en son itemi yayınlar."sample" modülü ekleriz.Mesela:
"const obsv2 = fromEvent(document,'click');
obsv1.pipe(sample(x => interval(2000))).subscribe(data=>console.log(data));
//Output:
Her 2 saniyede tek bir click değeri alır ve 2 saniye boyunca tıklamaların sadece son tıklama değerlerini alır ve yazdırır."
13-N-sampleTime = "sample" operatörünün parametreli[millisecond] halidir."sampleTime" modülü ekleriz.Mesela:
"const obsv2 = fromEvent(document,'click');
obsv1.pipe(sampleTime(2000)).subscribe(data=>console.log(data));
//Output:
Her 2 saniyede tek bir click değeri alır ve 2 saniye boyunca tıklamaların sadece son tıklama değerlerini alır ve yazdırır."
13-O-single = Belirtilen koşulu "Observable" objectlerine uygular.Eğer birden fazla value döndüdürse "error"; herhangi bir value döndürmezse de "undefined" döndürür.Yani kısaca, verilen koşula uygun olarak sadece bir adet value döndürülmelidir."single" modülü ekleriz.Mesela:
"const obsv1 = range(1,10).pipe(single(x=>x==9)).subscribe({
  next:data=>console.log(data),
  error:error=>console.log(error)
});
//Output:
Sadece bir adet 9 döndürecek."
------------------------------------------------------------------------------------------------------------------------------------------------
*****gRSPC Library: Remote Procedure Call.Uzak bir servardaki metodları, sanki kendi ortamının bir parçasıymış gibi çağırabildiği sistemdir.Veri iletimini[transport] HTTP2 protokolü üzerinden gerçekleştirir.Dataları "JSON" veya "XML" gibi text yerine "binary" formatına çevirerek gönderir.Fakat istersek yine "XML" veya "JSON" da tercih edilebilir.HTTP1 protokolü, "request" ve "response" mantığını kullandığı için, HTTP2'nin çalışma mantığı çok daha farklıdır.Farkları:
-Http1, her bir statik dosya için[.css,.js,.jpg,.png..] ayrı request gönderir.Bu durum, yük ve maaliyeti artırır.Metinsel tabanlıdır.Her requestinde "header"ları sıkıştırılmamış halde gönderir.Bir request olduğunda yalnızca bir response döner.
-Http2 ise dosyaları için tüm requestleri tek seferde toplu olarak yapabilmektedir.Böylece açılış hızı artmakta ve süresi düşmektedir.Buna "Multiplexing" denir.Teknik olarak tek bir "TCP"  bağlantısı üzerinden yapılan request ve responsetur.Client ile server arasındaki iletişimi "binary" formattaki küçük framelere ayırmaktadır.Bu duruma "Binary Protocol" denir.Her requestinde "header"ları "HPACK" ile sıkıştırarak gönderir.Bu duruma ise "Header Compression" denir.Bir reques olduğunda birden fazla response ile karşılık verebilir.Buna da "Server Push" denir.
--------------------------------------------------------------------------------------------------------------
*****ANGULAR PLAYGROUND:
***Bir componentin sanboxını oluşturmak için:
1-Mesela "nav" folderı içerisinde "NavComponent" bulunsun.CLI ile bu foldera gel.
"ng g angular-playground:sandbox nav --flat" yaz.Böylece aynı dizine, sandboxını ekleyecektir.
2-Sanboxın içerisine otomatik olarak şu ikisi import edilecektir: "import { sandboxOf } from 'angular-playground'" ve "import { NavComponent } from './nav.component'".Yani "nav" componentimize de erişimi var.
3-"npm run playground" ile run ederiz.Eğer serve ederken error alıyorsan, "angular-playground" içerisine gir."sandboxes.ts" gir ve import edilen componentlerin urllerini kontrol et.İmport pathlarında folderlar arasında ikişer tane "\\" bulunmalıdır.
--------------------------------------------------------------------------------------------------------------
*****TEMPLATES:
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
*****ngbootstrap carousel indicator styling:
1-Indicatorun rengini, boyutunu, aktif durumdaki stillerini şunlarla değiştiririz:
".carousel-indicators li {
  display: flex;
  color: black !important;
  background-color: white !important;
  justify-content: center;
  overflow: hidden;
  list-style-type: none;
  text-align: center;
  padding: 3px;
  margin: 0;
  width: 15px;
  white-space: nowrap;
  box-sizing: border-box;
  margin:5px;
  transition: all 1s ease-in-out !important;
  -moz-transition: all 1s ease-in-out !important;
  -ms-transition: all 1s ease-in-out !important;
  -webkit-transition: all 1s ease-in-out !important;
  -o-transition: all 1s ease-in-out !important;
  border-radius: 10px !important;
  opacity: 1 !important;
}
.carousel-indicators li.active{  
  background-color: black!important;
  border-radius: 0px !important;
}
a.carousel-control-prev:hover,
a.carousel-control-next:hover{	
  background-color: rgba(0, 0, 0, 0.3) !important;
}
a.carousel-control-prev span,
a.carousel-control-next span{      
  transform: scale(1.5,1.5)!important;
}
.carousel-item{
 overflow: hidden;
}
.carousel-item.active{  
  //Şimdilik burası None
}"
--------------------------------------------------------------------------------------------------------------
*****ngbootstrap toast service and customize:
1-Elimizde bir adet "CityaddComponent" ve bir adet "ToastService" var.Toast service gir ve şunları ekle:
"toasts: any[] = [];
showSuccess(textOrTpl: string | TemplateRef<any>,header:string | TemplateRef<any>):void {
  if(this.toasts.length>3){
    this.toasts.shift();
  }
  this.toasts.push({ textOrTpl, 
    classname: 'bg-success toast1 text-light',
    delay: 5000 ,
    animation:true,
    autohide: true,
    headertext: header
  });
}
showError(textOrTpl: string | TemplateRef<any>,header:string | TemplateRef<any>):void {
  if(this.toasts.length>3){
    this.toasts.shift();
  }
  this.toasts.push({ textOrTpl, 
    classname: 'bg-danger toast1 text-light',
    delay: 5000 ,
    animation:true,
    autohide: true,
    headertext: header
  });
}
remove(toast:any):void {
  this.toasts = this.toasts.filter(t => t !== toast);
}".
2-Böylece service ile çağırabileceğimiz toastları customize ettik.İçerisine 2 adet bootstrap classı ve "toast1" classı ekledik.Bu classı, root style olan "style.css" gir ve şöyle ekle:
".toast1{
  transition: all .3s ease-in-out !important;
  -moz-transition: all .3s ease-in-out!important;
  -webkit-transition: all .3s ease-in-out!important;
  -ms-transition: all .3s ease-in-out!important;
  -o-transition: all .3s ease-in-out!important;
  animation-name: toast1;
  animation-timing-function: ease-in-out;
  animation-duration: 1s;
}
.toast1:hover{
  border-bottom-left-radius: 35px;
  border-top-right-radius: 35px;
  box-shadow: rgb(38, 57, 77) 0px 20px 30px -10px;
}
@keyframes toast1{
  0% {transform: translateX(-100px);opacity:0}
  90% {transform: translateX(10px);opacity:1}
  100% {transform: translateX(0);}
}".
3-Artık efekt ve görsel olarak tostlar hazır.Şimdi ise proje içerisine bir adet "toast" component oluştur.Componenti şu şekilde düzenle:
"@Component({
  selector: 'app-toast',
  template: `
  <ngb-toast
  style='cursor:pointer;min-width:170px'
    *ngFor='let toast of toastService.toasts'
    [header]='toast.headertext'
    [class]='toast.classname'
    [autohide]='toast.autohide'
    [delay]='toast.delay || 5000'
    (hide)='toastService.remove(toast)'
    (click)='toastService.remove(toast)'
  >
    <ng-template [ngIf]='isTemplate(toast)' [ngIfElse]='text'>
      <ng-template [ngTemplateOutlet]='toast.textOrTpl'></ng-template>
    </ng-template>

    <ng-template #text>{{ toast.textOrTpl }}</ng-template>
  </ngb-toast>
`,
host: {'[class.ngb-toasts]': 'true'},
styleUrls:['./toast.component.css']
})
export class ToastComponent {

  constructor(public toastService:ToastService) { }
  isTemplate(toast:any) { return toast.textOrTpl instanceof TemplateRef; }
}".
4-Şimdi ise toastın pozisyonunu css ile değiştireceğiz.Toastın cssine şunu ekle:
":host {
  position: fixed;
  top: auto!important;
  bottom: 0!important;
  right: auto!important;
  right: 0!important;
  margin: 0.5em;
  z-index: 1200;
}".
5-Toast componentini yerleştirme vakti."app.component.html" gel ve burada "<app-toast></app-toast>" şeklinde ekle.Yapının en dışına ekle böylece router açıkken de görüntüleyebileceğiz.
6-Şimdi ise toastı kullanacağımız "cityadd" component gel.Toast servisi çağır ve consturctor içerisine ekle.Html kısmına şöyle bir buton ekle:
"<button (click)='test1()'>tıhh</button>".
7-Şimdi ise "cityadd" componente gel ve şunu ekle:
"this.toastService.showSuccess('Succesfully added','Congrats!')".
8-Artık çağırabiliyoruz ve hem header hem body kısmını her componente özgü olarak editleyebiliyoruz.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
*****Reactive formlarda dinamik olarak array grup eklemek:
****Bu senaryoda form ögesine object olarak itemler ekleyip post ediyoruz:
1-Öncelikle göndereceğimiz itemin modelini oluşturacağız."city" model oluştur ve şöyle yaz:
"export class City {
  id:number=0;
  name:string="";
  description:string="";
  images:{id:number,url:string,imageHeader:string,imageText:string}[]=[];
}".
2-"cityadd" componentine gel ve "cityForm!: FormGroup;" tanımla.
2-Ardından formu şöyle oluştur:
"createForm1() {
  this.cityForm = this.fb.group({
    name: ['', Validators.compose([Validators.required, Validators.minLength(3), Validators.maxLength(50)])],
    description: ['', Validators.compose([Validators.required, Validators.minLength(10), Validators.maxLength(250)])],
    images: this.fb.array([])
  })
}".
3-Ardından "ngOnInit" içerisinde şöyle çağır:
"this.createForm1()".
4-Ardından "getter" metodları şöyle çağır:
"get name() {
  return this.cityForm.get('name');
}
get description() {
  return this.cityForm.get('description');
}
get images() {
  return this.cityForm.get('images') as FormArray;
}".
5-Htmle gel ve formu şöyle oluştur:
"<form (ngSubmit)='onSubmit()' [formGroup]='cityForm' fxLayout='column wrap' fxLayoutGap='5px' fxLayoutAlign='center center'>
<div style='width:200px;'>
    <mat-form-field style='width: 100%' appearance='outline'>
        <mat-label>City name:</mat-label>
        <input formControlName='name' matInput placeholder='Placeholder'>
        <mat-icon style='color: green;' *ngIf='name?.valid&&(name?.dirty||name?.touched)' matSuffix>tag_faces</mat-icon>
        <mat-icon style='color: red;' *ngIf='name?.invalid&&(name?.dirty||name?.touched)' matSuffix>close</mat-icon>            
      </mat-form-field>
</div>
<div style='width:400px'>
    <mat-form-field style='width: 100%;' appearance='fill'>
        <mat-label>City description:</mat-label>
        <textarea formControlName='description' style='width: 100% !important;' matInput></textarea>
        <mat-hint style='color: red;' *ngIf='description?.invalid&&(description?.dirty||description?.touched)'>Min. 10 and Max. 250 character!</mat-hint>
      </mat-form-field>
</div>        
<div style='width: 400px;margin-top: 15px;' formArrayName='images'>
    <button type='button' (click)='addImages()'>Add City Images</button>
    <div style='width:100%' *ngFor='let x of images.controls; index as i'>
        <div style='width: 100%;' [formGroupName]='i'>                
            <mat-form-field style='width: 33.3%' appearance='outline'>
                <mat-label>Image URL:</mat-label>
                <input formControlName='url' matInput placeholder='URL'>
                <mat-icon style='color: green;' *ngIf='cityForm?.valid&&(cityForm?.dirty||cityForm?.touched)' matSuffix>tag_faces</mat-icon>
                <mat-icon style='color: red;' *ngIf='cityForm?.invalid&&(cityForm?.dirty||cityForm?.touched)' matSuffix>close</mat-icon>            
              </mat-form-field>            
              <mat-form-field style='width: 33.3%' appearance='outline'>
                <mat-label>Image Header:</mat-label>
                <input formControlName='imageHeader' matInput placeholder='Header'>
                <mat-icon style='color: green;' *ngIf='cityForm?.valid&&(cityForm?.dirty||cityForm?.touched)' matSuffix>tag_faces</mat-icon>
                <mat-icon style='color: red;' *ngIf='cityForm?.invalid&&(cityForm?.dirty||cityForm?.touched)' matSuffix>close</mat-icon>            
              </mat-form-field>            
              <mat-form-field style='width: 33.3%' appearance='outline'>
                <mat-label>Image Text:</mat-label>
                <input formControlName='imageText' matInput placeholder='Text'>
                <mat-icon style='color: green;' *ngIf='cityForm?.valid&&(cityForm?.dirty||cityForm?.touched)' matSuffix>tag_faces</mat-icon>
                <mat-icon style='color: red;' *ngIf='cityForm?.invalid&&(cityForm?.dirty||cityForm?.touched)' matSuffix>close</mat-icon>            
              </mat-form-field>            
        </div>
    </div>       
</div>    
<button type='submit' mat-raised-button color='primary'>Primary</button>    
</form>".
6-Şimdi ise butona eklediğimiz "addImages" fonksiyonunu componentte şöyle oluştururuz:
"addImages(){
  return this.images.push(this.fb.group({
    url:['',Validators.required],
    imageText:['',Validators.required],
    imageHeader:['',Validators.required]
  }))
}".
7-Böylece artık butona her tıkladığımızda, "images" içerisinde belirttiğimiz üzere 3 adet control inputu[url,imageText,imageHeader] eklenmiş olacaktır.
8-Şimdi ise post etmek için bir form kalıbını component içerisinde şöyle oluştur:
"sendForm: City = new City()"
9-Ardından forma atadığımız "onSubmit" fonksiyonunu şöyle çağır:
"onSubmit() {
  if (this.cityForm.valid) {
    this.sendForm = Object.assign({}, this.cityForm.value)
    this.cityService.addCity(this.sendForm).subscribe(data => {
      console.log(data)
    });
    this.cityForm.patchValue({
      name: "",
      description: ""
    }),
      alert('Success')
    this.router.navigate(['city']);
  }
  else {
    alert('Wrong!')
  }
}".